
 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Staff Roster Management System CP - Fixed</title>

  <!-- External Libraries for PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>

  <style>
  /* (All your CSS styles here - will include adjustments for table width) */
      /* =================== Global Style Variables =================== */
    :root {
      --primary-color: #4f46e5; /* Original primary color */
      --primary-hover: #4338ca; /* Original hover color */
      --button-color: #6c757d; /* Bootstrap secondary color (grey) */
      --button-hover: #5a6268; /* Slightly darker grey for hover */
      --button-active: #545b62; /* Even darker grey for active state */
      --secondary-color: #6B7280;
      --success-color: #10B981;
      --warning-color: #F59E0B;
      --danger-color: #EF4444;
      --light-bg: #f8f9fa; /* Bootstrap light background */
      --border-color: #dee2e6; /* Bootstrap border color */
      --text-color: #343a40; /* Bootstrap dark text color */
    }

    /* =================== Reset & Global Styles =================== */
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.5;
      text-align: center;
    }

    h2 { color: var(--text-color); /* Changed from primary-color */ margin-bottom: 25px; font-weight: 600; }
    h3, h4 { color: var(--text-color); margin: 20px 0 10px 0; }

    .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }

    .card {
      background: #fff; border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 20px; margin-bottom: 20px;
      border: 1px solid var(--border-color); /* Added border */
    }

    /* =================== Date & Gap Policy Section =================== */
    .date-container, .gap-policy-container {
      margin: 20px 0; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;
    }

    .date-container > div, .gap-policy-container > div {
      display: flex; align-items: center; gap: 8px;
    }

    /* =================== Table Styles =================== */
    table {
      width: 100%; border-collapse: collapse; margin: 20px 0;
      background: #fff; border-radius: 6px; overflow: hidden;
    }
    th, td {
      border: 1px solid var(--border-color); padding: 10px 8px; text-align: center;
    }
    th { background-color: var(--light-bg); /* Changed from primary-color */ color: var(--text-color); /* Changed from white */ font-weight: 600; }
    tr:nth-child(even) { background-color: rgba(0,0,0,0.05); } /* Slightly darker for even rows */
    tr:hover { background-color: rgba(0,0,0,0.075); } /* Darker hover */

    /* Freeze the first column ("Location") */
    #rosterContainer {
      overflow-x: auto;
    }
    #editableRoster thead th:first-child,
    #editableRoster tbody td:first-child {
      position: sticky;
      left: 0;
      background: #fff;
      z-index: 10;
    }

    /* =================== Form Element Styles =================== */
     input, select {
        padding: 8px 12px; /* Slightly larger padding */
        text-align: center;
        font-size: 14px; /* Slightly larger font */
        border: 1px solid var(--border-color);
        border-radius: 4px;
        transition: border-color 0.2s;
        background-color: #fff; /* Explicitly set background */
        color: var(--text-color); /* Ensure text color is consistent */
    }
    /* Placeholder text styling */
      input::placeholder, select::placeholder {
        color: #6c757d; /* Grey placeholder text */
    }

    input:focus, select:focus {
      outline: none; border-color: var(--button-color); /* Focus on grey, not blue */
      box-shadow: 0 0 0 2px rgba(108, 117, 125, 0.25); /* Grey focus shadow */
    }
    input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; } /* Larger checkbox */

    /* =================== Button Styles =================== */
    .button-container { display: flex; flex-direction: column; gap: 12px; margin: 20px 0; align-items: center; }
    .button-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    .roster-btn {
      background-color: var(--button-color); /* Grey button color */
      color: #fff;
      padding: 10px 20px; /* Larger padding */
      font-size: 14px; /* Slightly larger font */
      border-radius: 6px;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }
    .roster-btn:hover { background-color: var(--button-hover); transform: translateY(-1px); }
    .roster-btn:active { background-color: var(--button-active); transform: translateY(1px); box-shadow: none; /* Remove shadow on active */ }

    /* =================== Floating Break List Styles =================== */
    #breakListContainer {
      position: fixed; bottom: 20px; left: 20px; width: 240px; /* Slightly wider */ max-height: 350px; overflow: auto;
      background: #fff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 15px; /* More padding */
      font-size: 13px; text-align: left; cursor: move; z-index: 1000; transition: opacity 0.3s;
      border: 1px solid var(--border-color); /* Added border */
    }
    #breakListContainer.hidden { opacity: 0.2; }
    #breakListContainer:hover { opacity: 1; }

    /* =================== Status Message Styles =================== */
    .status-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
    .status-success { background-color: var(--success-color); }
    .status-warning { background-color: var(--warning-color); }
    .status-danger { background-color: var(--danger-color); }

    /* =================== Notification Styles =================== */
    #notification-container {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1001;
    }
    .notification {
      padding: 10px;
      margin-bottom: 5px;
      border-radius: 4px;
      min-width: 200px;
       /* Use Bootstrap contextual colors */
       &.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
       &.error   { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
       &.warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
       &.info    { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    }

    /* =================== Responsive Adjustments =================== */
    @media (max-width: 768px) {
      .date-container, .gap-policy-container { flex-direction: column; align-items: center; }
      .button-row { flex-direction: column; width: 100%; max-width: 200px; }
      .roster-btn { width: 100%; }
       /* Adjustments for smaller screens */
        input, select {
          padding: 6px 10px;
          font-size: 13px;
      }
    }
    /* Adjust Staff table width */
        #staffTable {
            table-layout: fixed; /* Important for consistent column widths */
        }
        #staffTable th:nth-child(1) { width: 80px; } /* Staff ID */
        #staffTable th:nth-child(2) { width: 120px; } /* Name */
        #staffTable th:nth-child(3) { width: 100px; } /* Break Time - Now narrower */
        #staffTable th:nth-child(4) { width: 60px; }  /* HHMD */
        #staffTable th:nth-child(5) { width: 60px; }  /* Attendance */
        #staffTable th:nth-child(6) { width: 50px; }  /* Lock */
        #staffTable th:nth-child(7) { width: 80px; }  /* Action*/

        /* Style for the break time input (single input) */
        .break-time-input {
            width: 90px; /*  width */
        }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <h2>Staff Roster Management System CP</h2>

    <!-- =================== Date & Gap Policy Section =================== -->
    <div class="card">
      <div class="date-container">
        <div>
          <label for="rosterDate">Roster Date:</label>
          <input type="date" id="rosterDate">
        </div>
        <div>
          <label for="rosterDay">Day:</label>
          <select id="rosterDay">
            <option value="Monday">Monday</option>
            <option value="Tuesday">Tuesday</option>
            <option value="Wednesday">Wednesday</option>
            <option value="Thursday">Thursday</option>
            <option value="Friday">Friday</option>
            <option value="Saturday">Saturday</option>
            <option value="Sunday">Sunday</option>
          </select>
        </div>
        <div>
          <label>Working Staff:</label>
          <span id="staffCount">0</span>
        </div>
      </div>
      <div class="gap-policy-container">
        <div>
          <label for="gapThreshold">Gap Threshold (minutes):</label>
          <input type="range" id="gapThreshold" min="30" max="120" step="15" value="120">
          <span id="gapThresholdValue">120</span>
        </div>
      </div>
    </div>

    <!-- =================== Staff Management Table & Buttons =================== -->
    <div class="card">
      <h3>Staff Management</h3>
      <div class="table-responsive">
        <table id="staffTable">
          <thead>
            <tr>
              <th>Staff ID</th>
              <th>Name</th>
              <th>Break Time</th>
              <th>HHMD Eligible</th>
              <th>Attendance</th>
              <th>Lock</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            <!-- Staff rows are dynamically added here -->
          </tbody>
        </table>
      </div>
      <div class="button-container">
        <div class="button-row">
          <button class="roster-btn" id="addStaffBtn">Add Staff</button>
          <button class="roster-btn" id="importDataBtn">Import Data</button>
          <button class="roster-btn" id="exportDataBtn">Export Data</button>
        </div>
        <div class="button-row">
          <button class="roster-btn" id="shuffleBreaksBtn">Shuffle Breaks</button>
          <button class="roster-btn" id="generateRosterBtn">Generate Roster</button>
          <button class="roster-btn" id="copyTSVBtn">Copy Roster</button>
        </div>
        <div class="button-row">
          <button class="roster-btn" id="downloadCSVBtn">CSV</button>
          <button class="roster-btn" id="downloadPDFBtn">PDF</button>
          <button class="roster-btn" id="toggleBreakNoteBtn">Toggle Break Note</button>
        </div>
      </div>
    </div>

    <!-- Hidden JSON Import Input -->
    <input type="file" id="importFile" accept=".json" />

    <!-- =================== Roster Display Section =================== -->
    <div class="card">
      <h3>Generated Roster</h3>
      <div id="rosterContainer">
        <!-- Roster table is dynamically generated here -->
      </div>
    </div>

    <!-- =================== Roster Health Report Section =================== -->
    <div class="card">
      <h4>Roster Health</h4>
      <div id="notesContainer">
        <!-- Roster health issues and notes are displayed here -->
      </div>
    </div>
  </div>

  <!-- =================== Floating Break List (Draggable) =================== -->
  <div id="breakListContainer">
    <strong>Staff Break Times</strong><br><br>
    <!-- List is dynamically updated -->
  </div>
  <!-- Notification container -->
    <div id="notification-container"></div>
  <!-- =================== JavaScript Section =================== -->
  <script>
    /**************************************************************
     * NOTE: STORAGE_KEY is defined here to be used for localStorage
     **************************************************************/
    const STORAGE_KEY = 'staffListData_v2';

    /**************************************************************
     * Global Constants for Roster & Scheduling
     * - Updated ROSTER_TIMES: Removed "07:30", added "06:30" and using "07:00" for Tango Papa.
     * - PRIORITY, OUTPUT_ORDER, and BREAK_TIME_POOL are defined for scheduling.
     **************************************************************/
    const ROSTER_TIMES = ["20:00","20:30","21:00","22:00","23:00","00:00","01:00","01:30","02:00","03:00","04:00","05:00","06:00","06:30","07:00"];
    const PRIORITY = [
      { location: "Pass Counter", needed: 2 },
      { location: "HHMD", needed: 1 },
      { location: "Lobby", needed: 2 },
      { location: "Guard House", needed: 1 },
      { location: "Vertical Patrol", needed: 1 },
      { location: "Report Room", needed: 1 },
      { location: "Tango Papa", needed: 1 }
    ];
    const OUTPUT_ORDER = ["Pass Counter", "HHMD", "Lobby", "Guard House", "Vertical Patrol", "Report Room", "Tango Papa"];
    const BREAK_TIME_POOL = [
        "20:00-21:30", "21:30-23:30", "22:00-00:00",
        "23:00-01:00", "00:00-02:00", "01:30-03:30",
        "02:00-04:00", "03:00-05:00", "04:00-06:00",
        "05:00-07:00", "06:00-08:00"
    ];
    // CRITICAL_LOCATIONS: For Tango Papa, critical time is now "07:00"
    const CRITICAL_LOCATIONS = {
      "Vertical Patrol": ["20:30", "23:00", "01:30", "06:00"],
      "Report Room": ["20:00", "21:00"],
      "Tango Papa": ["07:00"]
    };

    /**************************************************************
     * rosterSystem Object: Contains all functionality for:
     * - Initialization and Event Binding
     * - Staff Management (load, save, add, remove)
     * - Roster Generation (assignment, conflict checking, auto-correction)
     * - Display (Roster table, Break List, Roster Health)
     * - Export/Import (JSON, CSV, PDF, Copy TSV)
     **************************************************************/
    const rosterSystem = {
      generatedRosterData: null, // Encapsulated within the object
      lastValidationConflicts: {},

      /******************** Initialization ********************/
      init: function() {
        console.log("Initializing roster system...");
        // Check that required HTML elements exist
        const requiredElements = ['rosterDate','rosterDay','gapThreshold','staffCount','staffTable','addStaffBtn','importDataBtn','exportDataBtn','shuffleBreaksBtn','generateRosterBtn','copyTSVBtn','downloadCSVBtn','downloadPDFBtn','toggleBreakNoteBtn','importFile','rosterContainer','notesContainer','breakListContainer', 'notification-container'];
        const missing = requiredElements.filter(id => !document.getElementById(id));
        if(missing.length){
          console.error("Missing elements:", missing);
          this.showError("Missing required elements: " + missing.join(', '));
          return;
        }
        // Warn if jsPDF is missing (needed for PDF export)
        if(typeof jsPDF === 'undefined'){
          console.warn("jsPDF not loaded. PDF export may not work.");
          this.showWarning("PDF export may not work due to missing jsPDF library.");
        }
        // Set initial date and day
        this.initializeDateAndDay();
        // Bind all event listeners
        this.setupEventListeners();
        // Make the floating break list draggable
        this.makeDraggable(document.getElementById('breakListContainer'));
        // Load saved staff list (if any)
        this.loadStaffList();
        // Update break list display
        this.displayBreakList();
        console.log("Roster system initialized.");
        this.showSuccess("System initialized successfully.");
      },
      /******************** Initialization Helpers ********************/
      initializeDateAndDay: function(){
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        document.getElementById('rosterDate').value = dateStr;
        const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
        document.getElementById('rosterDay').value = days[today.getDay()];
      },
      setupEventListeners: function(){
        // Update gap threshold display and regenerate roster if needed
        const gapSlider = document.getElementById("gapThreshold");
        const gapDisplay = document.getElementById("gapThresholdValue");
        gapSlider.addEventListener("input", () => { gapDisplay.innerText = gapSlider.value; });
        gapSlider.addEventListener("change", () => { if(this.generatedRosterData) this.generateRoster(); });
        // Bind button click events
        document.getElementById("addStaffBtn").addEventListener("click", () => this.addStaff());
        document.getElementById("importDataBtn").addEventListener("click", () => this.importData());
        document.getElementById("exportDataBtn").addEventListener("click", () => this.exportData());
        document.getElementById("shuffleBreaksBtn").addEventListener("click", () => this.shuffleBreakTimes());
        document.getElementById("generateRosterBtn").addEventListener("click", () => this.generateRoster());
        document.getElementById("copyTSVBtn").addEventListener("click", () => this.copyTSV());
        document.getElementById("downloadCSVBtn").addEventListener("click", () => this.downloadRoster('csv'));
        document.getElementById("downloadPDFBtn").addEventListener("click", () => this.downloadRoster('pdf'));
        document.getElementById("toggleBreakNoteBtn").addEventListener("click", () => this.toggleBreakNote());
        document.getElementById("rosterDay").addEventListener("change", () => { if(this.generatedRosterData) this.generateRoster(); });
      },
      makeDraggable: function(el){
        if(!el) return;
        let pos = { top: 0, left: 0, x: 0, y: 0 };
        const mouseDownHandler = function(e){
          pos = { left: el.offsetLeft, top: el.offsetTop, x: e.clientX, y: e.clientY };
          document.addEventListener('mousemove', mouseMoveHandler);
          document.addEventListener('mouseup', mouseUpHandler);
          el.style.cursor = 'grabbing';
          el.style.userSelect = 'none';
        };
        const mouseMoveHandler = function(e){
          const dx = e.clientX - pos.x, dy = e.clientY - pos.y;
          let newLeft = pos.left + dx, newTop = pos.top + dy;
          const maxX = window.innerWidth - el.offsetWidth, maxY = window.innerHeight - el.offsetHeight;
          newLeft = Math.max(0, Math.min(newLeft, maxX));
          newTop = Math.max(0, Math.min(newTop, maxY));
          el.style.left = newLeft + 'px';
          el.style.top = newTop + 'px';
        };
        const mouseUpHandler = function(){
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
          el.style.cursor = 'grab';
          el.style.userSelect = '';
        };
        el.addEventListener('mousedown', mouseDownHandler);
        el.style.cursor = 'grab';
        el.style.position = 'fixed';
      },
      /******************** Notification Functions ********************/
        showSuccess: function (message) { this.showNotification(message, 'success'); },
        showError: function (message) { this.showNotification(message, 'error'); },
        showWarning: function (message) { this.showNotification(message, 'warning'); },
        showNotification: function (message, type = 'info') {
            const typeMap = { success: '✅ ', error: '❌ ', warning: '⚠️ ', info: 'ℹ️ ' };
            const container = document.getElementById("notification-container");
            const notification = document.createElement("div");
            notification.className = `notification ${type}`; // Add CSS classes for styling
            notification.textContent = typeMap[type] + message;
            container.appendChild(notification);

            // Automatically remove the notification after a few seconds
            setTimeout(() => {
                container.removeChild(notification);
            }, 5000); // Remove after 5 seconds
        },
      /******************** Staff Management Functions ********************/
      loadStaffList: function(){
        const stored = localStorage.getItem(STORAGE_KEY);
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        if(stored){
          try{
            const staffList = JSON.parse(stored);
            tbody.innerHTML = "";
            if(Array.isArray(staffList)){
              staffList.forEach(staff => { tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML(staff)); });
              this.showSuccess(`Loaded ${staffList.length} staff members.`);
            } else { throw new Error("Invalid staff data format."); }
          } catch(e){
            console.error("Error loading staff data:", e);
            this.showWarning("Could not load saved staff data. Starting with empty roster.");
            this.addStaff();
          }
        } else { this.addStaff(); }
        this.addListenersToAllRows();
        this.updateStaffCount();
      },
      saveStaffList: function(){
        try{
          const staffList = this.getCurrentStaffList();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(staffList));
          return true;
        } catch(e){
          console.error("Error saving staff list:", e);
          this.showError("Failed to save staff list: " + e.message);
          return false;
        }
      },
      getCurrentStaffList: function(){
        const rows = document.getElementById("staffTable").querySelector("tbody").rows;
        const staffList = [];
        for(let row of rows){
          try{
           // const timeInputs = row.cells[2].querySelectorAll("input[type='time']");  REMOVED
           // const startTime = timeInputs[0].value, endTime = timeInputs[1].value; REMOVED
           // const formatTime = time => {  REMOVED
            //  if(!time) return "00:00";
            //  const [h, m] = time.split(":").map(Number);
            //  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
           // };
           // const breakTime = `${formatTime(startTime)}-${formatTime(endTime)}`; REMOVED
            const breakTime = row.cells[2].querySelector("input").value.trim();  // ADDED: Get break time directly
            const assigned = row.dataset.assigned ? JSON.parse(row.dataset.assigned) : [];
            staffList.push({
              staffID: row.cells[0].querySelector("input").value.trim(),
              name: row.cells[1].querySelector("input").value.trim(),
              breakTime, // Use the direct string value
              hhmdEligible: row.cells[3].querySelector("select").value,
              attendance: row.cells[4].querySelector("select").value,
              locked: row.cells[5].querySelector("input[type='checkbox']").checked,
              assigned
            });
          } catch(err){
            console.error("Error processing row:", err);
          }
        }
        return staffList;
      },
    getStaffRowHTML: function(staff = {}) {
    const breakTime = staff.breakTime || "21:30-23:30"; // Default value
    return `
        <tr data-assigned='${JSON.stringify(staff.assigned || [])}'>
            <td><input type="text" value="${staff.staffID || ''}" class="staff-input" placeholder="ID"></td>
            <td><input type="text" value="${staff.name || ''}" class="staff-input" placeholder="Name"></td>
            <td><input type="text" value="${breakTime}" class="break-time-input" placeholder="HH:MM-HH:MM"></td>
            <td>
                <select class="staff-select">
                    <option value="Yes" ${staff.hhmdEligible === "Yes" ? "selected" : ""}>Yes</option>
                    <option value="No" ${staff.hhmdEligible === "No" ? "selected" : ""}>No</option>
                </select>
            </td>
            <td>
                <select class="staff-select">
                    <option value="Yes" ${staff.attendance === "Yes" ? "selected" : ""}>Yes</option>
                    <option value="No" ${staff.attendance === "No" ? "selected" : ""}>No</option>
                </select>
            </td>
            <td><input type="checkbox" ${staff.locked ? "checked" : ""} title="Lock this staff member"></td>
            <td><button class="remove-btn roster-btn" data-staff-id="${staff.staffID || ''}">Remove</button></td>
        </tr>`;
},
      addStaff: function(){
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        const newStaff = { staffID: "", name: "", breakTime: "21:30-23:30", hhmdEligible: "No", attendance: "Yes", locked: false, assigned: [] };
        tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML(newStaff));
        this.addListenersToAllRows();
        this.saveStaffList();
        this.updateStaffCount();
      },
      removeRow: function(button){
        const row = button.closest("tr");
        const staffID = button.getAttribute('data-staff-id');
        if(staffID && !confirm(`Remove staff ${staffID}?`)) return;
        row.remove();
        this.saveStaffList();
        this.updateStaffCount();
      },
    addListenersToAllRows: function() {
    const tbody = document.getElementById("staffTable").querySelector("tbody");
    const self = this;
    const inputs = tbody.querySelectorAll("input, select");

    inputs.forEach(inp => {
        inp.removeEventListener("change", inp._changeHandler);
        inp._changeHandler = function() {
            self.saveStaffList();
            self.updateStaffCount();
            self.displayBreakList();
            // Validate the break time format when it changes
            if (inp.classList.contains('break-time-input')) {
                self.validateBreakTimeInput(inp);
            }
        };
        inp.addEventListener("change", inp._changeHandler);
    });

        const removeButtons = tbody.querySelectorAll(".remove-btn");
        removeButtons.forEach(btn => {
          btn.removeEventListener("click", btn._clickHandler);
          btn._clickHandler = function(){ self.removeRow(this); };
          btn.addEventListener("click", btn._clickHandler);
        });
      },
    // Added input validation for break time
    validateBreakTimeInput: function(input) {
        if (!/^[0-2]?\d:[0-5]\d-[0-2]?\d:[0-5]\d$/.test(input.value)) {
            input.style.borderColor = "red"; // Highlight invalid input
            this.showError("Invalid break time format. Use HH:MM-HH:MM (e.g., 20:00-22:00).");
        } else {
            // Further check: Ensure end time is after start time
            const [start, end] = input.value.split("-");
            if(this.timeToMinutes(start) >= this.timeToMinutes(end)) {
                input.style.borderColor = "red";
                this.showError("Break end time must be after start time.");
                return; // Exit to prevent saving
            }
            input.style.borderColor = ""; // Reset to default
            this.showSuccess("Input Time is valid")
        }

    },

      updateStaffCount: function(){
        const staffList = this.getCurrentStaffList();
        const workingCount = staffList.filter(st => st.attendance === "Yes").length;
        document.getElementById("staffCount").textContent = workingCount;
        const countElement = document.getElementById("staffCount");
        if(workingCount < 5){ countElement.style.color = "red"; countElement.title = "Low staff count"; }
        else if(workingCount < 8){ countElement.style.color = "orange"; countElement.title = "Minimal staff count"; }
        else{ countElement.style.color = "green"; countElement.title = "Sufficient staff"; }
      },

      /******************** Roster Generation & Scheduling ********************/
      shuffleBreakTimes: function() {
        const staffList = this.getCurrentStaffList();
        let changedCount = 0;
        staffList.forEach(st => {
          if (st.attendance === "Yes" && !st.locked) {
            const randomIndex = Math.floor(Math.random() * BREAK_TIME_POOL.length);
            st.breakTime = BREAK_TIME_POOL[randomIndex];
            changedCount++;
          }
        });
        this.applyStaffListToTable(staffList);
        this.saveStaffList();
        this.displayBreakList();
        this.showSuccess(`Break times shuffled for ${changedCount} staff members!`);
      },
      applyStaffListToTable: function(staffList) {
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        tbody.innerHTML = "";
        staffList.forEach(staff => {
          tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML(staff));
        });
        this.addListenersToAllRows();
        this.updateStaffCount();
      },
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      /******************** Break List Display ********************/
      displayBreakList: function() {
        const container = document.getElementById("breakListContainer");
        const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        let html = "<strong>Staff Break Times</strong><br><br>";
        if (staffList.length === 0) {
          html += "<em>No staff scheduled</em>";
        } else {
          staffList.sort((a, b) => this.parseBreakTime(a.breakTime).start - this.parseBreakTime(b.breakTime).start);
          staffList.forEach(st => {
            html += `<strong>${st.staffID || "??"}</strong> (${st.name || "??"}): ${st.breakTime}`;
            if (st.locked) {
              html += " 🔒";
            }
            html += "<br>";
          });
        }
        container.innerHTML = html;
      },
      toggleBreakNote: function() {
        document.getElementById("breakListContainer").classList.toggle("hidden");
      },
      /******************** Import/Export Functions ********************/
      importData: function() {
        const fileInput = document.getElementById("importFile");
        fileInput.value = "";
        fileInput.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const importedStaff = JSON.parse(text);
            if (!Array.isArray(importedStaff)) throw new Error("Invalid JSON structure.  Expected an array.");
            importedStaff.forEach(staff => {
              if (!staff.breakTime || !/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(staff.breakTime))
                throw new Error(`Invalid break time for staff ${staff.staffID}: ${staff.breakTime}`);

              // Chronological validation (already present - good!)
              const [start, end] = staff.breakTime.split("-");
              const startTime = this.timeToMinutes(start);
              const endTime = this.timeToMinutes(end);

              if (endTime <= startTime) {
                throw new Error(`Invalid break time for staff ${staff.staffID}: End time must be after start time.`);
              }
            });
            localStorage.setItem(STORAGE_KEY, JSON.stringify(importedStaff));
            this.loadStaffList();
            this.displayBreakList();
            this.showSuccess(`Imported ${importedStaff.length} staff records successfully.`);
          } catch (err) {
            console.error("Import error:", err);
            this.showError("Error importing data: " + err.message);
          }
        };
        fileInput.click();
      },
      exportData: function() {
        try {
          const staffList = this.getCurrentStaffList();
          if (staffList.length === 0) {
            this.showWarning("No staff data to export.");
            return;
          }
          const jsonStr = JSON.stringify(staffList, null, 2);
          const blob = new Blob([jsonStr], {
            type: "application/json"
          });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          const date = new Date().toISOString().split('T')[0];
          link.href = url;
          link.download = `staff_data_${date}.json`;
          link.click();
          URL.revokeObjectURL(url);
          this.showSuccess(`Exported ${staffList.length} staff records successfully.`);
        } catch (error) {
          console.error("Export error:", error);
          this.showError("Error exporting data: " + error.message);
        }
      },


      /******************** Roster Generation & Conflict Resolution ********************/
    generateRoster: function() {
        const dayValue = document.getElementById("rosterDay").value;
        const isWeekend = ["Saturday", "Sunday"].includes(dayValue);
        let staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        if (staffList.length === 0) {
            this.showError("Add staff before generating roster."); return;
        }

        staffList.forEach(st => { if (!st.locked) st.assigned = []; });

        let roster = this.initializeRoster();
        let shortfalls = [];

        this.assignCritical(roster, staffList, isWeekend, shortfalls);
        this.checkCriticalShortfalls(roster, isWeekend, shortfalls);
        this.assignNonCritical(roster, staffList, isWeekend, shortfalls);
        this.addBufferStaff(roster, staffList, isWeekend);

        this.generatedRosterData = this.createDisplayData(roster);

        const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
        this.autoCorrect(this.generatedRosterData, staffList, gapThreshold);

        this.saveAssignedToRows(staffList);
        const creationTime = new Date();
        this.displayRoster(this.generatedRosterData, this.lastValidationConflicts, creationTime);
        this.displayNotes(shortfalls);
        this.displayBreakList();

        const healthStatus = shortfalls.length === 0 ? "Optimal roster generated!"
                                                    : `Roster generated with ${shortfalls.length} issues.`;
        this.showSuccess(healthStatus);
        return { roster: this.generatedRosterData, shortfalls };
    },

    initializeRoster: function() {
        let roster = {};
        PRIORITY.forEach(({ location }) => { roster[location] = {}; });
        return roster;
    },

    assignCritical: function(roster, staffList, isWeekend, shortfalls) {
        for (const loc in CRITICAL_LOCATIONS) {
            if (loc === "Report Room" && isWeekend) continue;
            for (const slot of CRITICAL_LOCATIONS[loc]) {
                if (!this.locationApplies(loc, slot, isWeekend)) continue;
                if (!roster[loc][slot]) roster[loc][slot] = "";

                let chosen = this.findAvailableStaff(staffList, slot, loc);
                if (chosen) {
                    let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
                    roster[loc][slot] += (roster[loc][slot] ? separator : "") + chosen.staffID;
                    chosen.assigned.push({ slot, location: loc });
                } else {
                    chosen = this.findEmergencyStaff(staffList, slot, loc); // Pass loc here
                    if (chosen) {
                        let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
                        roster[loc][slot] += (roster[loc][slot] ? separator : "") + chosen.staffID;
                        chosen.assigned.push({ slot, location: loc });
                        shortfalls.push(`Emergency: ${chosen.staffID} assigned to ${loc} at ${slot}`);
                    } else {
                        shortfalls.push(`CRITICAL: Could not fill ${loc} at ${slot}`);
                    }
                }
            }
        }

        // Check for completely empty locations:
        for (const loc in roster) {
            let allEmpty = true;
            for (const slot in roster[loc]) {
                if (roster[loc][slot] && roster[loc][slot].trim() !== "") {
                    allEmpty = false;
                    break;
                }
            }
            if (allEmpty) shortfalls.push(`CRITICAL: ${loc} has zero assignments.`);
        }
    },

    checkCriticalShortfalls: function(roster, isWeekend, shortfalls) {
        const vpTimes = ["20:30", "23:00", "01:30", "06:00"];
        for (let time of vpTimes) {
            if (!roster["Vertical Patrol"][time] || roster["Vertical Patrol"][time].length === 0)
                shortfalls.push(`Missing Vertical Patrol at ${time}`);
        }
        if (!isWeekend) {
            const reportTimes = ["20:00", "21:00"];
            for (let time of reportTimes) {
                if (!roster["Report Room"][time] || roster["Report Room"][time].length === 0)
                    shortfalls.push(`Missing Report Room at ${time}`);
            }
        }
        if (!roster["Tango Papa"]["07:00"] || roster["Tango Papa"]["07:00"].length === 0)
            shortfalls.push(`Missing Tango Papa at 07:00`);

        for (const slot of ROSTER_TIMES) {
            if(slot === '07:00') continue; //skip 07:00 check
            const count = roster["Pass Counter"][slot] ? roster["Pass Counter"][slot].split(" | ").filter(Boolean).length : 0;
            if (count < 2) shortfalls.push(`CRITICAL: Pass Counter at ${slot} has ${count}/2 staff`);
        }

        for (const slot of ROSTER_TIMES) {
            if (!roster["HHMD"][slot] || roster["HHMD"][slot].length === 0)
                shortfalls.push(`CRITICAL: HHMD at ${slot} has no staff assigned`);
        }
    },
    assignNonCritical: function(roster, staffList, isWeekend, shortfalls) {
        for (let p of PRIORITY) {
            const loc = p.location, needed = p.needed;
            for (let slot of ROSTER_TIMES) {
                if (!this.locationApplies(loc, slot, isWeekend)) continue;
                if (!roster[loc][slot]) roster[loc][slot] = "";

                let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
                const assignedIDs = roster[loc][slot].split(separator).map(s => s.trim()).filter(Boolean);
                const stillNeeded = needed - assignedIDs.length;
                if (stillNeeded <= 0) continue;

                for (let i = 0; i < stillNeeded; i++) {
                    const availableStaff = this.findAvailableStaff(staffList, slot, loc);
                    if (availableStaff && !this.wouldCauseConflict(roster, availableStaff, slot, loc)) {
                        roster[loc][slot] += (roster[loc][slot] ? separator : "") + availableStaff.staffID;
                        availableStaff.assigned.push({ slot, location: loc });
                    } else {
                        if(assignedIDs.length + i === 0) { // Check if this is the *first* missing staff
                            shortfalls.push(`CRITICAL: No staff available for ${loc} at ${slot}`);
                        } else {
                            shortfalls.push(`Shortfall: ${loc} at ${slot} has only ${assignedIDs.length + i}/${needed} staff`);
                        }
                        break; // Stop trying on this slot
                    }
                }
            }
        }
    },

    addBufferStaff: function(roster, staffList, isWeekend) {
        if (roster["Pass Counter"]) {
            ROSTER_TIMES.forEach(slot => {
                if (!this.locationApplies("Pass Counter", slot, isWeekend)) return;
                if (roster["Pass Counter"][slot]) {
                    let visibleAssignments = roster["Pass Counter"][slot].split(" | ").filter(id => !id.includes("*"));
                    if (visibleAssignments.length === PRIORITY.find(p => p.location === "Pass Counter").needed) {
                        let bufferStaff = this.findAvailableStaff(staffList, slot, "Pass Counter");
                        if (bufferStaff && !this.wouldCauseConflict(roster, bufferStaff, slot, "Pass Counter")) {
                            roster["Pass Counter"][slot] += " | " + bufferStaff.staffID + "*";
                            bufferStaff.assigned.push({ slot, location: "Pass Counter", buffer: true });
                        }
                    }
                }
            });
        }
    },

    // *** IMPORTANT: Sorting Staff IDs within createDisplayData ***
    createDisplayData: function(roster) {
        let displayData = {};
        OUTPUT_ORDER.forEach(loc => {
            displayData[loc] = {};
            ROSTER_TIMES.forEach(slot => {
                let ids = [];
                if (roster[loc] && roster[loc][slot]) {
                    let tokens = (loc === "Pass Counter" || loc === "Lobby") ? roster[loc][slot].split(" | ") : roster[loc][slot].split(",");
                    // Trim, filter out empty strings and buffers, THEN sort numerically:
                    ids = tokens.map(s => s.trim()).filter(id => id && !id.includes("*")).sort((a,b) => parseInt(a) - parseInt(b));
                }
                displayData[loc][slot] = (loc === "Pass Counter" || loc === "Lobby") ? ids.join(" | ") : ids.join(", ");
            });
        });
        return displayData;
    },
    autoCorrect: function(roster, staffList, gapThreshold) {
        const maxIterations = 20;
        let iteration = 0;
        let { issues, conflicts } = this.validateRoster(roster, gapThreshold);
        this.lastValidationConflicts = conflicts;

        while (issues.length > 0 && iteration < maxIterations) {
            if (!this.autoCorrectRoster(roster, staffList, conflicts)) break;
            ({ issues, conflicts } = this.validateRoster(roster, gapThreshold));
            this.lastValidationConflicts = conflicts;
            iteration++;
        }

        if (issues.length > 0 && gapThreshold > 60) {
            const reducedThreshold = 60;
            iteration = 0;
            while (issues.length > 0 && iteration < maxIterations) {
                if (!this.autoCorrectRoster(roster, staffList, conflicts)) break;
                ({ issues, conflicts } = this.validateRoster(roster, reducedThreshold));
                this.lastValidationConflicts = conflicts;
                iteration++;
            }
            if (issues.length > 0) {
                shortfalls.push(...issues.filter(issue => !issue.includes("violates")));
            }
        } else if (issues.length > 0) {
            shortfalls.push(...issues);
        }
    },

   findEmergencyStaff: function(staffList, slot, loc) { // Added loc parameter
        // Prioritize staff who are *not* locked.
        const availableStaff = staffList.filter(st =>
            st.attendance === "Yes" &&
            !this.isOnBreak(st, slot) &&
            !this.isDoubleBooked(st, slot) &&
            this.locationApplies(loc, slot, document.getElementById("rosterDay").value) // Added location check
             && !(loc === "HHMD" && st.hhmdEligible !== "Yes")
        );

        const unlockedStaff = availableStaff.filter(st => !st.locked);
        if (unlockedStaff.length > 0) {
            return unlockedStaff.sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0))[0];
        }

        // If no unlocked staff, consider locked staff
        const lockedStaff = availableStaff.filter(st => st.locked);
        if (lockedStaff.length > 0) {
            return lockedStaff.sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0))[0];
        }

        return null; // No staff available
    },
    findAvailableStaff: function(staffList, slot, loc) {
        const sortedStaff = [...staffList].sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0));

        for (let st of sortedStaff) {
            if (st.attendance === "Yes" &&
                !this.isOnBreak(st, slot) &&
                !this.isDoubleBooked(st, slot) &&
                !(loc === "HHMD" && st.hhmdEligible !== "Yes") &&
                this.locationApplies(loc, slot, document.getElementById("rosterDay").value) // Key addition
            ) {
                return st;
            }
        }
        return null;
    },

    isOnBreak: function(st, slot) {
        if (!st.breakTime || !st.breakTime.includes("-")) return false;
        if (!/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(st.breakTime)) {
            console.warn("Invalid break time format:", st.staffID, st.breakTime);
            return false;
        }
        const [bStart, bEnd] = st.breakTime.split("-");
        const slotTime = this.timeToMinutes(slot);
        const breakStart = this.timeToMinutes(bStart);
        const breakEnd = this.timeToMinutes(bEnd);

        if (breakStart <= breakEnd) {
            return slotTime >= breakStart && slotTime <= breakEnd;
        } else {
            return slotTime >= breakStart || slotTime <= breakEnd;
        }
    },

    isDoubleBooked: function(st, slot) {
        return st.assigned && st.assigned.some(a => a.slot === slot);
    },

   wouldCauseConflict: function(roster, staff, slot, loc) {
    if (this.isOnBreak(staff, slot) || this.isDoubleBooked(staff, slot)) return true;

    const potentialAssignments = [...staff.assigned.filter(a => !a.buffer), { slot, location: loc }];
    potentialAssignments.sort((a, b) => ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot));

    const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;

    for (let i = 0; i < potentialAssignments.length - 1; i++) {
        const current = potentialAssignments[i];
        const next = potentialAssignments[i + 1];

        // Direct time comparison for consecutive slots at the same location
        if (current.location === next.location) {
            const currentTime = this.timeToMinutes(current.slot);
            const nextTime = this.timeToMinutes(next.slot);

            if (nextTime > currentTime && nextTime - currentTime < gapThreshold) {
                return true; // Gap violation
            }
        }
    }

    return false;
},
    autoCorrectRoster: function(roster, staffList, conflicts) {
        let correctionsMade = false;
        for (let loc in conflicts) {
            for (let slot in conflicts[loc]) {
                for (let staffID in conflicts[loc][slot]) {
                    let staff = staffList.find(s => s.staffID === staffID);
                    if (staff) {
                        this.removeAssignment(roster, staff, slot, loc);
                        let currentAssignments = roster[loc][slot]
                            .split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",")
                            .map(s => s.trim()).filter(Boolean);
                        // Remove duplicates after removing the conflicting assignment
                        roster[loc][slot] = [...new Set(currentAssignments)].join((loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ");

                        if (slot !== "07:00" || loc === "Tango Papa") {
                            let newStaff = this.findEmergencyStaff(staffList.filter(s => s.staffID !== staffID), slot, loc); // Use emergency
                            if (newStaff && !this.wouldCauseConflict(roster, newStaff, slot, loc) && !this.isOnBreak(newStaff, slot)) {
                                roster[loc][slot] = roster[loc][slot]
                                    ? ((loc === "Pass Counter" || loc === "Lobby") ? roster[loc][slot] + " | " + newStaff.staffID : roster[loc][slot] + ", " + newStaff.staffID)
                                    : newStaff.staffID;
                                newStaff.assigned.push({ slot, location: loc });
                                correctionsMade = true;
                            } else {
                                correctionsMade = true; // Still count as a correction
                            }
                        } else {
                             correctionsMade = true;
                        }
                    }
                }
            }
        }
        return correctionsMade;
    },

    removeAssignment: function(roster, staff, slot, loc) {
        staff.assigned = staff.assigned.filter(a => !(a.slot === slot && a.location === loc));
        if (roster[loc] && roster[loc][slot]) {
            let ids = roster[loc][slot].split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
            ids = ids.filter(id => id !== staff.staffID);
            roster[loc][slot] = ids.join((loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ");
        }
    },
    validateRoster: function(roster, gapThreshold = 120) {
        const staffAssignments = {};
        const issues = [];
        const conflicts = {};
        const staffList = this.getCurrentStaffList();

        function addConflict(loc, slot, staffID, conflictType) {
            if (!conflicts[loc]) conflicts[loc] = {};
            if (!conflicts[loc][slot]) conflicts[loc][slot] = {};
            if (!conflicts[loc][slot][staffID]) conflicts[loc][slot][staffID] = [];
            conflicts[loc][slot][staffID].push(conflictType);
        }

        for (const loc in roster) {
            for (const slot in roster[loc]) {
                const staffListStr = roster[loc][slot];
                if (!staffListStr) continue;

                if (slot === "07:00" && loc !== "Tango Papa") {
                    const staffIDs = staffListStr.split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
                    staffIDs.forEach(staffID => {
                        issues.push(`Staff ${staffID} assigned at ${loc} for 07:00, reserved for Tango Papa`);
                        addConflict(loc, slot, staffID, "invalid0700");
                    });
                    continue;
                }

                const staffIDs = staffListStr.split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
                const uniqueStaffIDs = new Set(staffIDs);
                if (uniqueStaffIDs.size < staffIDs.length) {
                    const duplicates = staffIDs.filter((id, index) => staffIDs.indexOf(id) !== index);
                    duplicates.forEach(id => {
                        issues.push(`Staff ${id} listed multiple times at ${loc} for ${slot}`);
                        addConflict(loc, slot, id, "duplicateAssignment");
                    });
                }

                for (const staffID of staffIDs) {
                    const staff = staffList.find(s => s.staffID === staffID);

                  //  if (staff && rosterSystem.isOnBreak(staff, slot)) {   -- No need to check anymore since this will handle findAvailableStaff
                  //      issues.push(`Staff ${staffID} assigned at ${loc} during break at ${slot}`);
                  //     addConflict(loc, slot, staffID, "breakViolation");
                  //  }

                    if (!staffAssignments[staffID]) staffAssignments[staffID] = [];
                    const existingAssignment = staffAssignments[staffID].find(a => a.slot === slot);
                    if (existingAssignment) {
                        issues.push(`Staff ${staffID} double-booked at ${slot}: ${existingAssignment.location} and ${loc}`);
                        addConflict(loc, slot, staffID, "doubleBooked");
                        addConflict(existingAssignment.location, slot, staffID, "doubleBooked");
                    }

                    staffAssignments[staffID].push({ slot, location: loc, buffer: false });
                }
            }
        }

        for (const staffID in staffAssignments) {
            const assignments = staffAssignments[staffID].sort((a, b) => ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot));
            for (let i = 0; i < assignments.length - 1; i++) {
                const curr = assignments[i];
                const next = assignments[i + 1];

                if (curr.location === next.location &&
                    Math.abs(ROSTER_TIMES.indexOf(curr.slot) - ROSTER_TIMES.indexOf(next.slot)) === 1) {
                    issues.push(`Staff ${staffID} has consecutive assignments at ${curr.location}: ${curr.slot} and ${next.slot}`);
                    addConflict(curr.location, curr.slot, staffID, "consecutive");
                    addConflict(next.location, next.slot, staffID, "consecutive");
                }

                if (curr.location === next.location) {
                    const currTime = rosterSystem.timeToMinutes(curr.slot);
                    const nextTime = rosterSystem.timeToMinutes(next.slot);
                    if (nextTime - currTime < gapThreshold && nextTime - currTime > 0) {
                        issues.push(`Staff ${staffID} violates ${gapThreshold/60}-hour gap at ${curr.location}: ${curr.slot} and ${next.slot}`);
                        addConflict(curr.location, curr.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
                        addConflict(next.location, next.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
                    }
                }
            }
        }

        return { issues, conflicts };
    },
      saveAssignedToRows: function(staffList) {
        const rows = document.getElementById("staffTable").querySelector("tbody").rows;
        for (let i = 0; i < rows.length; i++) {
          const staffID = rows[i].cells[0].querySelector("input").value.trim();
          const staff = staffList.find(s => s.staffID === staffID);
          if (staff) {
            // Save the assignments to the 'data-assigned' attribute of the row
            rows[i].dataset.assigned = JSON.stringify(staff.assigned);
          }
        }
        this.saveStaffList(); // crucial to save after roster generation
      },

/******************** Display Functions ********************/
     displayRoster: function(roster, conflicts = {}, creationTime) {
        const container = document.getElementById("rosterContainer");
        const rosterDate = document.getElementById("rosterDate").value;
        const dayValue = document.getElementById("rosterDay").value;

        let headerHTML = `<div style="text-align:left; margin-bottom:15px; font-size:13px; display:flex; justify-content: space-between; flex-wrap: wrap;">
            <div><strong>Roster Date:</strong> ${rosterDate} (${dayValue})</div>
            <div><strong>Generated:</strong> ${creationTime.toLocaleString()}</div>
        </div>`;

        let tableHTML = `<table id="editableRoster" class="roster-table"><thead><tr><th style="min-width:100px;">Location</th>`;
        ROSTER_TIMES.forEach(slot => tableHTML += `<th>${slot}</th>`);
        tableHTML += `</tr></thead><tbody>`;
        const isWeekend = ["Saturday", "Sunday"].includes(dayValue);

        OUTPUT_ORDER.forEach(loc => {
            tableHTML += `<tr data-loc="${loc}"><td><strong>${loc}</strong></td>`;
            ROSTER_TIMES.forEach(slot => {
                const applies = this.locationApplies(loc, slot, isWeekend);
                let assignedStr = applies ? (roster[loc]?.[slot] || "") : "";
                let staffIDs = (loc === "Pass Counter" || loc === "Lobby") ? assignedStr.split(" | ") : assignedStr.split(",");
                staffIDs = staffIDs.map(s => s.trim()).filter(Boolean);

                let cellClass = "", cellStyle = "";
                if (!applies) {
                    cellStyle = "background-color:#f8f8f8; color:#999;";
                    cellClass = "non-applicable";
                } else if (conflicts[loc] && conflicts[loc][slot]) {
                    cellStyle = "background-color:#ffd2d2;";
                    cellClass = "conflict";
                } else if (applies && !staffIDs.length) {
                    cellStyle = "background-color:#ffcccc;";
                    cellClass = "empty";
                } else if (CRITICAL_LOCATIONS[loc] && CRITICAL_LOCATIONS[loc].includes(slot)) {
                    cellStyle = "background-color:#e2f0ff;";
                    cellClass = "critical";
                }
                tableHTML += `<td contenteditable="true" data-slot="${slot}" class="${cellClass}" style="min-width:80px; ${cellStyle}" title="${applies ? 'Edit' : 'N/A'}">${assignedStr}</td>`;
            });
            tableHTML += "</tr>";
        });
        tableHTML += "</tbody></table>";

        let saveButtonHTML = `<div style="margin-top:15px; text-align:right;"><button class="roster-btn" id="saveEditsBtn">Save Edits</button></div>`;
        container.innerHTML = headerHTML + tableHTML + saveButtonHTML;
        document.getElementById("saveEditsBtn").addEventListener("click", () => this.saveEditedRoster());

        const editableCells = container.querySelectorAll("td[contenteditable='true']");
        editableCells.forEach(cell => {
            cell.addEventListener("focus", () => cell.style.boxShadow = "0 0 0 2px rgba(108, 117, 125, 0.4)");
            cell.addEventListener("blur", () => cell.style.boxShadow = "");
        });
    },
      // displayNotes: Shows first 3 issues by default, with a toggle to reveal/hide more.
      displayNotes: function(shortfalls) {
        const notesContainer = document.getElementById("notesContainer");
        if (shortfalls.length === 0) {
          notesContainer.innerHTML = `<div class="status-message success"><span class="status-indicator status-success"></span> Roster Health: All clear. No issues detected.</div>`;
        } else {
          // Show only the first 3 issues initially
          const visibleCount = 3;
          const visibleNotes = shortfalls.slice(0, visibleCount);
          const hiddenNotes = shortfalls.slice(visibleCount);

          let notesHtml = `<ul class="shortfall-list" style="text-align:left; margin-top:10px; font-size:12px;">`;
          visibleNotes.forEach(note => {
            // Style critical notes differently
            const style = note.toUpperCase().includes("CRITICAL") ? "color:#EF4444; font-weight:bold;" : "color:#F59E0B;";
            notesHtml += `<li style="${style}">${note}</li>`;
          });
          notesHtml += `</ul>`;

          // If there are more than 3 issues, add a "Show More" button
          if (hiddenNotes.length > 0) {
            notesHtml += `<div id="hiddenNotes" style="display:none;"><ul class="shortfall-list" style="text-align:left; margin-top:10px; font-size:12px;">`;
            hiddenNotes.forEach(note => {
              const style = note.toUpperCase().includes("CRITICAL") ? "color:#EF4444; font-weight:bold;" : "color:#F59E0B;";
              notesHtml += `<li style="${style}">${note}</li>`;
            });
            notesHtml += `</ul></div>`;
            notesHtml += `<button id="toggleNotesBtn" class="roster-btn" style="font-size:12px; margin-top:5px;">Show More</button>`;
          }

          notesContainer.innerHTML = `<div class="status-message"><span class="status-indicator status-danger"></span> Roster Health: ${shortfalls.length} issues</div>` + notesHtml;

          // Add event listener to the "Show More" button (if it exists)
          document.getElementById("toggleNotesBtn")?.addEventListener("click", function() {
            const hiddenDiv = document.getElementById("hiddenNotes");
            if (hiddenDiv.style.display === "none") {
              hiddenDiv.style.display = "block";
              this.textContent = "Show Less";
            } else {
              hiddenDiv.style.display = "none";
              this.textContent = "Show More";
            }
          });
        }
      },
       saveEditedRoster: function(){
        try{
          const rosterTable = document.getElementById("editableRoster");
          if(!rosterTable){
            this.showError("No roster table found.");
            return;
          }

          // 1. Get the current Staff List
          const staffList = this.getCurrentStaffList();

          // 2. Clear existing assignments for all staff *not* locked.
          staffList.forEach(staff => {
            if(!staff.locked) staff.assigned = [];  // Reset assignments for unlocked staff
          });

          // 3. Iterate over the EDITED roster table
          const rows = rosterTable.querySelectorAll("tbody tr");
          rows.forEach(row => {
            const location = row.getAttribute("data-loc");
            const cells = row.querySelectorAll("td[data-slot]");

            cells.forEach(cell => {
              const slot = cell.getAttribute("data-slot");
              const staffIDs = cell.textContent.split((location==="Pass Counter"||location==="Lobby")?" | ":",").map(id => id.trim()).filter(Boolean);

              staffIDs.forEach(staffID => {
                //Find staff in the staffList
                const staff = staffList.find(s => s.staffID === staffID);

                // *CRUCIAL*: Only re-assign if ATTENDING and NOT LOCKED.
                if(staff && staff.attendance === "Yes" && !staff.locked){
                  staff.assigned.push({slot, location});
                }
              });
            });
          });

          // 4. Apply Changes and Re-validate/Display:
          this.applyStaffListToTable(staffList); //apply changes to the staff table on UI
          this.saveAssignedToRows(staffList); // This ALSO saves to localStorage
          const gapThreshold = parseInt(document.getElementById("gapThreshold").value,10) || 120;
          const {issues, conflicts} = this.validateRoster(this.getEditableRosterData(), gapThreshold); // re-validate using NEW data
          this.lastValidationConflicts = conflicts; //store updated conflicts.
          this.displayNotes(issues); //display any errors.
          this.displayRoster(this.getEditableRosterData(), conflicts, new Date()); // Re-display with updated conflicts

          this.showSuccess("Roster edits saved successfully!");
        } catch(error){
          console.error("Error saving roster edits:", error);
          this.showError("Failed to save roster edits: " + error.message);
        }
      },
      getEditableRosterData: function() {
        const rosterTable = document.getElementById("editableRoster");
        if (!rosterTable) return {}; // Return empty object if no table

        const roster = {};
        const rows = rosterTable.querySelectorAll("tbody tr");
        rows.forEach(row => {
          const location = row.getAttribute("data-loc");
          roster[location] = {};
          const cells = row.querySelectorAll("td[data-slot]");
          cells.forEach(cell => {
            const slot = cell.getAttribute("data-slot");
            roster[location][slot] = cell.textContent.trim();
          });
        });
        return roster;
      },
      getTableData: function() {
        const rosterTable = document.getElementById("editableRoster");
        if (!rosterTable) return []; // Return empty array if no table

        const data = [];
        rosterTable.querySelectorAll("tr").forEach(row => {
          const rowData = [];
          row.querySelectorAll("th, td").forEach(cell => {
            rowData.push(cell.textContent.trim());
          });
          data.push(rowData);
        });
        return data;
      },

 /******************** Export Functions ********************/
      copyTSV: function() {
        const tableData = this.getTableData();
        const tsv = tableData.map(row => row.join("\t")).join("\n");
        navigator.clipboard.writeText(tsv).then(() => this.showSuccess("Roster copied as TSV."), () => this.showError("Failed to copy TSV."));
      },
      downloadRoster: function(format) {
        if (format === "csv") this.downloadAsCSV();
        else if (format === "pdf") this.downloadAsPDF();
      },
    downloadAsCSV: function() {
        const tableData = this.getTableData();
        const rosterDate = document.getElementById("rosterDate").value;
        const dayValue = document.getElementById("rosterDay").value;
        const creationTime = new Date().toLocaleString();

        // Add a header row to the CSV data
        const headerRow = [`Roster Date: ${rosterDate} (${dayValue})`, `Generated: ${creationTime}`];
        const csvData = [headerRow, ...tableData].map(row => row.join(",")).join("\n");

        const blob = new Blob([csvData], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const date = new Date().toISOString().split("T")[0];
        link.href = url;
        link.download = `roster_${date}.csv`;
        link.click();
        URL.revokeObjectURL(url);
        this.showSuccess("CSV file downloaded successfully.");
    },
    downloadAsPDF: function() {
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        const rosterDate = document.getElementById("rosterDate").value;
        const dayValue = document.getElementById("rosterDay").value;
        const creationTime = new Date().toLocaleString();

        // --- Title and Header ---
        doc.setFontSize(16);
        doc.text(`Staff Roster - ${rosterDate} (${dayValue})`, 14, 20);
        doc.setFontSize(10);
        doc.text(`Generated: ${creationTime}`, 14, 28);  // Adjusted y-coordinate


        const tableData = this.getTableData();

        // --- Main Roster Table ---
        doc.autoTable({
            head: [tableData[0]], // Header row
            body: tableData.slice(1), // Data rows
            startY: 36,  // Start below the title and generation time
            margin: { top: 36 }, // Ensure enough space
            styles: {
                halign: 'center',
                valign: 'middle',
                cellPadding: 2, // Reduced padding
                fontSize: 9,
                lineColor: [0, 0, 0], // Black border
                lineWidth: 0.5, // Thicker border
            },
            headStyles: {
                fillColor: [108, 117, 125], // Grey background
                textColor: 255, // White text
                halign: 'center',
                fontStyle: 'bold',
            },
            columnStyles: {
                0: { cellWidth: 80 }, // Location column wider
               // 1: { cellWidth: 20 }, // Example: Adjust other columns as needed
               // 2: { cellWidth: 20 },
               // ... and so on for all columns
            },
            // Remove "Not applicable text"
            didParseCell: function (data) {
                const cell = data.cell;
                if (cell.raw && cell.raw.includes && cell.raw.includes('Not applicable')) {
                  data.cell.text = '';
                }
            },

             // Add thin lines *within* cells for multiple staff
            didDrawCell: function(data) {
                if (data.section === 'body' && data.column.index !== 0) { // Skip location column
                    const cell = data.cell;
                    const lines = cell.text;
                    if (lines.length > 1) { // Multiple staff
                        let y = cell.y + cell.padding('top');
                        for (let i = 1; i < lines.length; i++) {
                            y += cell.textLineHeight; // Move down to the next line position
                            doc.setLineWidth(0.1); // Thinner line
                            doc.line(cell.x, y, cell.x + cell.width, y); // Horizontal line
                        }
                        doc.setLineWidth(0.5); //restore to normal width
                    }
                }
            }

        });

        // --- Break Time List ---
        const breakListData = this.getCurrentStaffList()
                                  .filter(staff => staff.attendance === "Yes")
                                   //Modify output format
                                  .map(staff => `${staff.staffID} (${staff.name}): ${staff.breakTime}`);

        if (breakListData.length > 0) {
            const breakListX = 14; // Left margin
            let breakListY = doc.autoTable.previous.finalY + 10; // Start below the main table

            doc.setFontSize(12);
            doc.text("Staff Break Times", breakListX, breakListY);
            breakListY += 5;
            doc.setFontSize(10);

            breakListData.forEach(item => {
              doc.text(item, breakListX, breakListY);
              breakListY += 5; // Fixed vertical spacing
                 // Check if we need a new page
                if (breakListY > 280) { // Assuming A4 page height is about 297mm
                    doc.addPage();
                    breakListY = 20; // Reset Y position for the new page
                 }

            });
        }


        const date = new Date().toISOString().split("T")[0];
        doc.save(`roster_${date}.pdf`);
        this.showSuccess("PDF file downloaded successfully.");
    } catch (e) {
        console.error("PDF download error:", e);
        this.showError("Failed to download PDF: " + e.message);
    }
},
 /******************** Utility Functions ********************/
    timeToMinutes: function(timeStr) {
        if (!timeStr || !/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(timeStr)) {
            console.warn("Invalid time format:", timeStr);
            return 0; // Or throw an error, depending on your needs
        }
        let [hours, minutes] = timeStr.split(":").map(Number);
        // Adjust for the 20:00 start time.  Times before 08:00 are considered next-day.
        if (hours < 8) {
            hours += 24; // Add 24 hours to shift to the next day
        }
        return (hours - 20) * 60 + minutes;
    },

    locationApplies: function(loc, slot, isWeekend) {
        //Tango Papa only at 07:00
        if(loc === "Tango Papa") return slot === "07:00";

        //Vertical Patrol only at specific times.
        if(loc === "Vertical Patrol") {
            return ["20:30", "23:00", "01:30", "06:00"].includes(slot);
        }
        if (slot === "06:30" && loc !== "Vertical Patrol") return false;
        if (slot === "07:00" && loc !== "Tango Papa") return false;
        if (loc === "Report Room" && isWeekend) return false;

        return true; // All other locations/slots are valid
      },
      parseBreakTime: function(breakTime) {
        if (!breakTime || !breakTime.includes("-")) return {
          start: 0,
          end: 0
        };
        const [start, end] = breakTime.split("-");
        return {
          start: this.timeToMinutes(start),
          end: this.timeToMinutes(end)
        };
      },
    };

    // Expose rosterSystem globally (if needed)
    window.RosterApp = rosterSystem;

    /**************************************************************
     * DOMContentLoaded: Initialize the system once the DOM is ready.
     * This ensures all elements exist before any event bindings are applied.
     **************************************************************/
    document.addEventListener("DOMContentLoaded", () => {
      rosterSystem.init();
    });
  </script>
</body>
</html>

      
      
      
      
      
      
      
      
      
      
      
      
      
      
      /******************** Break List Display ********************/
      displayBreakList: function() {
        const container = document.getElementById("breakListContainer");
        const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        let html = "<strong>Staff Break Times</strong><br><br>";
        if (staffList.length === 0) {
          html += "<em>No staff scheduled</em>";
        } else {
          staffList.sort((a, b) => this.parseBreakTime(a.breakTime).start - this.parseBreakTime(b.breakTime).start);
          staffList.forEach(st => {
            html += `<strong>${st.staffID || "??"}</strong> (${st.name || "??"}): ${st.breakTime}`;
            if (st.locked) {
              html += " 🔒";
            }
            html += "<br>";
          });
        }
        container.innerHTML = html;
      },
      toggleBreakNote: function() {
        document.getElementById("breakListContainer").classList.toggle("hidden");
      },
      /******************** Import/Export Functions ********************/
      importData: function() {
        const fileInput = document.getElementById("importFile");
        fileInput.value = "";
        fileInput.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const importedStaff = JSON.parse(text);
            if (!Array.isArray(importedStaff)) throw new Error("Invalid JSON structure.  Expected an array.");
            importedStaff.forEach(staff => {
              if (!staff.breakTime || !/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(staff.breakTime))
                throw new Error(`Invalid break time for staff ${staff.staffID}: ${staff.breakTime}`);

              // Chronological validation (already present - good!)
              const [start, end] = staff.breakTime.split("-");
              const startTime = this.timeToMinutes(start);
              const endTime = this.timeToMinutes(end);

              if (endTime <= startTime) {
                throw new Error(`Invalid break time for staff ${staff.staffID}: End time must be after start time.`);
              }
            });
            localStorage.setItem(STORAGE_KEY, JSON.stringify(importedStaff));
            this.loadStaffList();
            this.displayBreakList();
            this.showSuccess(`Imported ${importedStaff.length} staff records successfully.`);
          } catch (err) {
            console.error("Import error:", err);
            this.showError("Error importing data: " + err.message);
          }
        };
        fileInput.click();
      },
      exportData: function() {
        try {
          const staffList = this.getCurrentStaffList();
          if (staffList.length === 0) {
            this.showWarning("No staff data to export.");
            return;
          }
          const jsonStr = JSON.stringify(staffList, null, 2);
          const blob = new Blob([jsonStr], {
            type: "application/json"
          });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          const date = new Date().toISOString().split('T')[0];
          link.href = url;
          link.download = `staff_data_${date}.json`;
          link.click();
          URL.revokeObjectURL(url);
          this.showSuccess(`Exported ${staffList.length} staff records successfully.`);
        } catch (error) {
          console.error("Export error:", error);
          this.showError("Error exporting data: " + error.message);
        }
      },


      /******************** Roster Generation & Conflict Resolution ********************/
    generateRoster: function() {
        const dayValue = document.getElementById("rosterDay").value;
        const isWeekend = ["Saturday", "Sunday"].includes(dayValue);
        let staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        if (staffList.length === 0) {
            this.showError("Add staff before generating roster."); return;
        }

        staffList.forEach(st => { if (!st.locked) st.assigned = []; });

        let roster = this.initializeRoster();
        let shortfalls = [];

        this.assignCritical(roster, staffList, isWeekend, shortfalls);
        this.checkCriticalShortfalls(roster, isWeekend, shortfalls);
        this.assignNonCritical(roster, staffList, isWeekend, shortfalls);
        this.addBufferStaff(roster, staffList, isWeekend);

        this.generatedRosterData = this.createDisplayData(roster);

        const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
        this.autoCorrect(this.generatedRosterData, staffList, gapThreshold);

        this.saveAssignedToRows(staffList);
        const creationTime = new Date();
        this.displayRoster(this.generatedRosterData, this.lastValidationConflicts, creationTime);
        this.displayNotes(shortfalls);
        this.displayBreakList();

        const healthStatus = shortfalls.length === 0 ? "Optimal roster generated!"
                                                    : `Roster generated with ${shortfalls.length} issues.`;
        this.showSuccess(healthStatus);
        return { roster: this.generatedRosterData, shortfalls };
    },

    initializeRoster: function() {
        let roster = {};
        PRIORITY.forEach(({ location }) => { roster[location] = {}; });
        return roster;
    },

    assignCritical: function(roster, staffList, isWeekend, shortfalls) {
        for (const loc in CRITICAL_LOCATIONS) {
            if (loc === "Report Room" && isWeekend) continue;
            for (const slot of CRITICAL_LOCATIONS[loc]) {
                if (!this.locationApplies(loc, slot, isWeekend)) continue;
                if (!roster[loc][slot]) roster[loc][slot] = "";

                let chosen = this.findAvailableStaff(staffList, slot, loc);
                if (chosen) {
                    let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
                    roster[loc][slot] += (roster[loc][slot] ? separator : "") + chosen.staffID;
                    chosen.assigned.push({ slot, location: loc });
                } else {
                    chosen = this.findEmergencyStaff(staffList, slot, loc); // Pass loc here
                    if (chosen) {
                        let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
                        roster[loc][slot] += (roster[loc][slot] ? separator : "") + chosen.staffID;
                        chosen.assigned.push({ slot, location: loc });
                        shortfalls.push(`Emergency: ${chosen.staffID} assigned to ${loc} at ${slot}`);
                    } else {
                        shortfalls.push(`CRITICAL: Could not fill ${loc} at ${slot}`);
                    }
                }
            }
        }

        // Check for completely empty locations:
        for (const loc in roster) {
            let allEmpty = true;
            for (const slot in roster[loc]) {
                if (roster[loc][slot] && roster[loc][slot].trim() !== "") {
                    allEmpty = false;
                    break;
                }
            }
            if (allEmpty) shortfalls.push(`CRITICAL: ${loc} has zero assignments.`);
        }
    },

    checkCriticalShortfalls: function(roster, isWeekend, shortfalls) {
        const vpTimes = ["20:30", "23:00", "01:30", "06:00"];
        for (let time of vpTimes) {
            if (!roster["Vertical Patrol"][time] || roster["Vertical Patrol"][time].length === 0)
                shortfalls.push(`Missing Vertical Patrol at ${time}`);
        }
        if (!isWeekend) {
            const reportTimes = ["20:00", "21:00"];
            for (let time of reportTimes) {
                if (!roster["Report Room"][time] || roster["Report Room"][time].length === 0)
                    shortfalls.push(`Missing Report Room at ${time}`);
            }
        }
        if (!roster["Tango Papa"]["07:00"] || roster["Tango Papa"]["07:00"].length === 0)
            shortfalls.push(`Missing Tango Papa at 07:00`);

        for (const slot of ROSTER_TIMES) {
            if(slot === '07:00') continue; //skip 07:00 check
            const count = roster["Pass Counter"][slot] ? roster["Pass Counter"][slot].split(" | ").filter(Boolean).length : 0;
            if (count < 2) shortfalls.push(`CRITICAL: Pass Counter at ${slot} has ${count}/2 staff`);
        }

        for (const slot of ROSTER_TIMES) {
            if (!roster["HHMD"][slot] || roster["HHMD"][slot].length === 0)
                shortfalls.push(`CRITICAL: HHMD at ${slot} has no staff assigned`);
        }
    },
    assignNonCritical: function(roster, staffList, isWeekend, shortfalls) {
        for (let p of PRIORITY) {
            const loc = p.location, needed = p.needed;
            for (let slot of ROSTER_TIMES) {
                if (!this.locationApplies(loc, slot, isWeekend)) continue;
                if (!roster[loc][slot]) roster[loc][slot] = "";

                let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
                const assignedIDs = roster[loc][slot].split(separator).map(s => s.trim()).filter(Boolean);
                const stillNeeded = needed - assignedIDs.length;
                if (stillNeeded <= 0) continue;

                for (let i = 0; i < stillNeeded; i++) {
                    const availableStaff = this.findAvailableStaff(staffList, slot, loc);
                    if (availableStaff && !this.wouldCauseConflict(roster, availableStaff, slot, loc)) {
                        roster[loc][slot] += (roster[loc][slot] ? separator : "") + availableStaff.staffID;
                        availableStaff.assigned.push({ slot, location: loc });
                    } else {
                        if(assignedIDs.length + i === 0) { // Check if this is the *first* missing staff
                            shortfalls.push(`CRITICAL: No staff available for ${loc} at ${slot}`);
                        } else {
                            shortfalls.push(`Shortfall: ${loc} at ${slot} has only ${assignedIDs.length + i}/${needed} staff`);
                        }
                        break; // Stop trying on this slot
                    }
                }
            }
        }
    },

    addBufferStaff: function(roster, staffList, isWeekend) {
        if (roster["Pass Counter"]) {
            ROSTER_TIMES.forEach(slot => {
                if (!this.locationApplies("Pass Counter", slot, isWeekend)) return;
                if (roster["Pass Counter"][slot]) {
                    let visibleAssignments = roster["Pass Counter"][slot].split(" | ").filter(id => !id.includes("*"));
                    if (visibleAssignments.length === PRIORITY.find(p => p.location === "Pass Counter").needed) {
                        let bufferStaff = this.findAvailableStaff(staffList, slot, "Pass Counter");
                        if (bufferStaff && !this.wouldCauseConflict(roster, bufferStaff, slot, "Pass Counter")) {
                            roster["Pass Counter"][slot] += " | " + bufferStaff.staffID + "*";
                            bufferStaff.assigned.push({ slot, location: "Pass Counter", buffer: true });
                        }
                    }
                }
            });
        }
    },

    // *** IMPORTANT: Sorting Staff IDs within createDisplayData ***
    createDisplayData: function(roster) {
        let displayData = {};
        OUTPUT_ORDER.forEach(loc => {
            displayData[loc] = {};
            ROSTER_TIMES.forEach(slot => {
                let ids = [];
                if (roster[loc] && roster[loc][slot]) {
                    let tokens = (loc === "Pass Counter" || loc === "Lobby") ? roster[loc][slot].split(" | ") : roster[loc][slot].split(",");
                    // Trim, filter out empty strings and buffers, THEN sort numerically:
                    ids = tokens.map(s => s.trim()).filter(id => id && !id.includes("*")).sort((a,b) => parseInt(a) - parseInt(b));
                }
                displayData[loc][slot] = (loc === "Pass Counter" || loc === "Lobby") ? ids.join(" | ") : ids.join(", ");
            });
        });
        return displayData;
    },
    autoCorrect: function(roster, staffList, gapThreshold) {
        const maxIterations = 20;
        let iteration = 0;
        let { issues, conflicts } = this.validateRoster(roster, gapThreshold);
        this.lastValidationConflicts = conflicts;

        while (issues.length > 0 && iteration < maxIterations) {
            if (!this.autoCorrectRoster(roster, staffList, conflicts)) break;
            ({ issues, conflicts } = this.validateRoster(roster, gapThreshold));
            this.lastValidationConflicts = conflicts;
            iteration++;
        }

        if (issues.length > 0 && gapThreshold > 60) {
            const reducedThreshold = 60;
            iteration = 0;
            while (issues.length > 0 && iteration < maxIterations) {
                if (!this.autoCorrectRoster(roster, staffList, conflicts)) break;
                ({ issues, conflicts } = this.validateRoster(roster, reducedThreshold));
                this.lastValidationConflicts = conflicts;
                iteration++;
            }
            if (issues.length > 0) {
                shortfalls.push(...issues.filter(issue => !issue.includes("violates")));
            }
        } else if (issues.length > 0) {
            shortfalls.push(...issues);
        }
    },

   findEmergencyStaff: function(staffList, slot, loc) { // Added loc parameter
        // Prioritize staff who are *not* locked.
        const availableStaff = staffList.filter(st =>
            st.attendance === "Yes" &&
            !this.isOnBreak(st, slot) &&
            !this.isDoubleBooked(st, slot) &&
            this.locationApplies(loc, slot, document.getElementById("rosterDay").value) // Added location check
             && !(loc === "HHMD" && st.hhmdEligible !== "Yes")
        );

        const unlockedStaff = availableStaff.filter(st => !st.locked);
        if (unlockedStaff.length > 0) {
            return unlockedStaff.sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0))[0];
        }

        // If no unlocked staff, consider locked staff
        const lockedStaff = availableStaff.filter(st => st.locked);
        if (lockedStaff.length > 0) {
            return lockedStaff.sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0))[0];
        }

        return null; // No staff available
    },
    findAvailableStaff: function(staffList, slot, loc) {
        const sortedStaff = [...staffList].sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0));

        for (let st of sortedStaff) {
            if (st.attendance === "Yes" &&
                !this.isOnBreak(st, slot) &&
                !this.isDoubleBooked(st, slot) &&
                !(loc === "HHMD" && st.hhmdEligible !== "Yes") &&
                this.locationApplies(loc, slot, document.getElementById("rosterDay").value) // Key addition
            ) {
                return st;
            }
        }
        return null;
    },

    isOnBreak: function(st, slot) {
        if (!st.breakTime || !st.breakTime.includes("-")) return false;
        if (!/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(st.breakTime)) {
            console.warn("Invalid break time format:", st.staffID, st.breakTime);
            return false;
        }
        const [bStart, bEnd] = st.breakTime.split("-");
        const slotTime = this.timeToMinutes(slot);
        const breakStart = this.timeToMinutes(bStart);
        const breakEnd = this.timeToMinutes(bEnd);

        if (breakStart <= breakEnd) {
            return slotTime >= breakStart && slotTime <= breakEnd;
        } else {
            return slotTime >= breakStart || slotTime <= breakEnd;
        }
    },

    isDoubleBooked: function(st, slot) {
        return st.assigned && st.assigned.some(a => a.slot === slot);
    },

   wouldCauseConflict: function(roster, staff, slot, loc) {
    if (this.isOnBreak(staff, slot) || this.isDoubleBooked(staff, slot)) return true;

    const potentialAssignments = [...staff.assigned.filter(a => !a.buffer), { slot, location: loc }];
    potentialAssignments.sort((a, b) => ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot));

    const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;

    for (let i = 0; i < potentialAssignments.length - 1; i++) {
        const current = potentialAssignments[i];
        const next = potentialAssignments[i + 1];

        // Direct time comparison for consecutive slots at the same location
        if (current.location === next.location) {
            const currentTime = this.timeToMinutes(current.slot);
            const nextTime = this.timeToMinutes(next.slot);

            if (nextTime > currentTime && nextTime - currentTime < gapThreshold) {
                return true; // Gap violation
            }
        }
    }

    return false;
},
    autoCorrectRoster: function(roster, staffList, conflicts) {
        let correctionsMade = false;
        for (let loc in conflicts) {
            for (let slot in conflicts[loc]) {
                for (let staffID in conflicts[loc][slot]) {
                    let staff = staffList.find(s => s.staffID === staffID);
                    if (staff) {
                        this.removeAssignment(roster, staff, slot, loc);
                        let currentAssignments = roster[loc][slot]
                            .split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",")
                            .map(s => s.trim()).filter(Boolean);
                        // Remove duplicates after removing the conflicting assignment
                        roster[loc][slot] = [...new Set(currentAssignments)].join((loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ");

                        if (slot !== "07:00" || loc === "Tango Papa") {
                            let newStaff = this.findEmergencyStaff(staffList.filter(s => s.staffID !== staffID), slot, loc); // Use emergency
                            if (newStaff && !this.wouldCauseConflict(roster, newStaff, slot, loc) && !this.isOnBreak(newStaff, slot)) {
                                roster[loc][slot] = roster[loc][slot]
                                    ? ((loc === "Pass Counter" || loc === "Lobby") ? roster[loc][slot] + " | " + newStaff.staffID : roster[loc][slot] + ", " + newStaff.staffID)
                                    : newStaff.staffID;
                                newStaff.assigned.push({ slot, location: loc });
                                correctionsMade = true;
                            } else {
                                correctionsMade = true; // Still count as a correction
                            }
                        } else {
                             correctionsMade = true;
                        }
                    }
                }
            }
        }
        return correctionsMade;
    },

    removeAssignment: function(roster, staff, slot, loc) {
        staff.assigned = staff.assigned.filter(a => !(a.slot === slot && a.location === loc));
        if (roster[loc] && roster[loc][slot]) {
            let ids = roster[loc][slot].split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
            ids = ids.filter(id => id !== staff.staffID);
            roster[loc][slot] = ids.join((loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ");
        }
    },
    validateRoster: function(roster, gapThreshold = 120) {
        const staffAssignments = {};
        const issues = [];
        const conflicts = {};
        const staffList = this.getCurrentStaffList();

        function addConflict(loc, slot, staffID, conflictType) {
            if (!conflicts[loc]) conflicts[loc] = {};
            if (!conflicts[loc][slot]) conflicts[loc][slot] = {};
            if (!conflicts[loc][slot][staffID]) conflicts[loc][slot][staffID] = [];
            conflicts[loc][slot][staffID].push(conflictType);
        }

        for (const loc in roster) {
            for (const slot in roster[loc]) {
                const staffListStr = roster[loc][slot];
                if (!staffListStr) continue;

                if (slot === "07:00" && loc !== "Tango Papa") {
                    const staffIDs = staffListStr.split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
                    staffIDs.forEach(staffID => {
                        issues.push(`Staff ${staffID} assigned at ${loc} for 07:00, reserved for Tango Papa`);
                        addConflict(loc, slot, staffID, "invalid0700");
                    });
                    continue;
                }

                const staffIDs = staffListStr.split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
                const uniqueStaffIDs = new Set(staffIDs);
                if (uniqueStaffIDs.size < staffIDs.length) {
                    const duplicates = staffIDs.filter((id, index) => staffIDs.indexOf(id) !== index);
                    duplicates.forEach(id => {
                        issues.push(`Staff ${id} listed multiple times at ${loc} for ${slot}`);
                        addConflict(loc, slot, id, "duplicateAssignment");
                    });
                }

                for (const staffID of staffIDs) {
                    const staff = staffList.find(s => s.staffID === staffID);

                  //  if (staff && rosterSystem.isOnBreak(staff, slot)) {   -- No need to check anymore since this will handle findAvailableStaff
                  //      issues.push(`Staff ${staffID} assigned at ${loc} during break at ${slot}`);
                  //     addConflict(loc, slot, staffID, "breakViolation");
                  //  }

                    if (!staffAssignments[staffID]) staffAssignments[staffID] = [];
                    const existingAssignment = staffAssignments[staffID].find(a => a.slot === slot);
                    if (existingAssignment) {
                        issues.push(`Staff ${staffID} double-booked at ${slot}: ${existingAssignment.location} and ${loc}`);
                        addConflict(loc, slot, staffID, "doubleBooked");
                        addConflict(existingAssignment.location, slot, staffID, "doubleBooked");
                    }

                    staffAssignments[staffID].push({ slot, location: loc, buffer: false });
                }
            }
        }

        for (const staffID in staffAssignments) {
            const assignments = staffAssignments[staffID].sort((a, b) => ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot));
            for (let i = 0; i < assignments.length - 1; i++) {
                const curr = assignments[i];
                const next = assignments[i + 1];

                if (curr.location === next.location &&
                    Math.abs(ROSTER_TIMES.indexOf(curr.slot) - ROSTER_TIMES.indexOf(next.slot)) === 1) {
                    issues.push(`Staff ${staffID} has consecutive assignments at ${curr.location}: ${curr.slot} and ${next.slot}`);
                    addConflict(curr.location, curr.slot, staffID, "consecutive");
                    addConflict(next.location, next.slot, staffID, "consecutive");
                }

                if (curr.location === next.location) {
                    const currTime = rosterSystem.timeToMinutes(curr.slot);
                    const nextTime = rosterSystem.timeToMinutes(next.slot);
                    if (nextTime - currTime < gapThreshold && nextTime - currTime > 0) {
                        issues.push(`Staff ${staffID} violates ${gapThreshold/60}-hour gap at ${curr.location}: ${curr.slot} and ${next.slot}`);
                        addConflict(curr.location, curr.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
                        addConflict(next.location, next.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
                    }
                }
            }
        }

        return { issues, conflicts };
    },
      saveAssignedToRows: function(staffList) {
        const rows = document.getElementById("staffTable").querySelector("tbody").rows;
        for (let i = 0; i < rows.length; i++) {
          const staffID = rows[i].cells[0].querySelector("input").value.trim();
          const staff = staffList.find(s => s.staffID === staffID);
          if (staff) {
            // Save the assignments to the 'data-assigned' attribute of the row
            rows[i].dataset.assigned = JSON.stringify(staff.assigned);
          }
        }
        this.saveStaffList(); // crucial to save after roster generation
      },

/******************** Display Functions ********************/
     displayRoster: function(roster, conflicts = {}, creationTime) {
        const container = document.getElementById("rosterContainer");
        const rosterDate = document.getElementById("rosterDate").value;
        const dayValue = document.getElementById("rosterDay").value;

        let headerHTML = `<div style="text-align:left; margin-bottom:15px; font-size:13px; display:flex; justify-content: space-between; flex-wrap: wrap;">
            <div><strong>Roster Date:</strong> ${rosterDate} (${dayValue})</div>
            <div><strong>Generated:</strong> ${creationTime.toLocaleString()}</div>
        </div>`;

        let tableHTML = `<table id="editableRoster" class="roster-table"><thead><tr><th style="min-width:100px;">Location</th>`;
        ROSTER_TIMES.forEach(slot => tableHTML += `<th>${slot}</th>`);
        tableHTML += `</tr></thead><tbody>`;
        const isWeekend = ["Saturday", "Sunday"].includes(dayValue);

        OUTPUT_ORDER.forEach(loc => {
            tableHTML += `<tr data-loc="${loc}"><td><strong>${loc}</strong></td>`;
            ROSTER_TIMES.forEach(slot => {
                const applies = this.locationApplies(loc, slot, isWeekend);
                let assignedStr = applies ? (roster[loc]?.[slot] || "") : "";
                let staffIDs = (loc === "Pass Counter" || loc === "Lobby") ? assignedStr.split(" | ") : assignedStr.split(",");
                staffIDs = staffIDs.map(s => s.trim()).filter(Boolean);

                let cellClass = "", cellStyle = "";
                if (!applies) {
                    cellStyle = "background-color:#f8f8f8; color:#999;";
                    cellClass = "non-applicable";
                } else if (conflicts[loc] && conflicts[loc][slot]) {
                    cellStyle = "background-color:#ffd2d2;";
                    cellClass = "conflict";
                } else if (applies && !staffIDs.length) {
                    cellStyle = "background-color:#ffcccc;";
                    cellClass = "empty";
                } else if (CRITICAL_LOCATIONS[loc] && CRITICAL_LOCATIONS[loc].includes(slot)) {
                    cellStyle = "background-color:#e2f0ff;";
                    cellClass = "critical";
                }
                tableHTML += `<td contenteditable="true" data-slot="${slot}" class="${cellClass}" style="min-width:80px; ${cellStyle}" title="${applies ? 'Edit' : 'N/A'}">${assignedStr}</td>`;
            });
            tableHTML += "</tr>";
        });
        tableHTML += "</tbody></table>";

        let saveButtonHTML = `<div style="margin-top:15px; text-align:right;"><button class="roster-btn" id="saveEditsBtn">Save Edits</button></div>`;
        container.innerHTML = headerHTML + tableHTML + saveButtonHTML;
        document.getElementById("saveEditsBtn").addEventListener("click", () => this.saveEditedRoster());

        const editableCells = container.querySelectorAll("td[contenteditable='true']");
        editableCells.forEach(cell => {
            cell.addEventListener("focus", () => cell.style.boxShadow = "0 0 0 2px rgba(108, 117, 125, 0.4)");
            cell.addEventListener("blur", () => cell.style.boxShadow = "");
        });
    },
      // displayNotes: Shows first 3 issues by default, with a toggle to reveal/hide more.
      displayNotes: function(shortfalls) {
        const notesContainer = document.getElementById("notesContainer");
        if (shortfalls.length === 0) {
          notesContainer.innerHTML = `<div class="status-message success"><span class="status-indicator status-success"></span> Roster Health: All clear. No issues detected.</div>`;
        } else {
          // Show only the first 3 issues initially
          const visibleCount = 3;
          const visibleNotes = shortfalls.slice(0, visibleCount);
          const hiddenNotes = shortfalls.slice(visibleCount);

          let notesHtml = `<ul class="shortfall-list" style="text-align:left; margin-top:10px; font-size:12px;">`;
          visibleNotes.forEach(note => {
            // Style critical notes differently
            const style = note.toUpperCase().includes("CRITICAL") ? "color:#EF4444; font-weight:bold;" : "color:#F59E0B;";
            notesHtml += `<li style="${style}">${note}</li>`;
          });
          notesHtml += `</ul>`;

          // If there are more than 3 issues, add a "Show More" button
          if (hiddenNotes.length > 0) {
            notesHtml += `<div id="hiddenNotes" style="display:none;"><ul class="shortfall-list" style="text-align:left; margin-top:10px; font-size:12px;">`;
            hiddenNotes.forEach(note => {
              const style = note.toUpperCase().includes("CRITICAL") ? "color:#EF4444; font-weight:bold;" : "color:#F59E0B;";
              notesHtml += `<li style="${style}">${note}</li>`;
            });
            notesHtml += `</ul></div>`;
            notesHtml += `<button id="toggleNotesBtn" class="roster-btn" style="font-size:12px; margin-top:5px;">Show More</button>`;
          }

          notesContainer.innerHTML = `<div class="status-message"><span class="status-indicator status-danger"></span> Roster Health: ${shortfalls.length} issues</div>` + notesHtml;

          // Add event listener to the "Show More" button (if it exists)
          document.getElementById("toggleNotesBtn")?.addEventListener("click", function() {
            const hiddenDiv = document.getElementById("hiddenNotes");
            if (hiddenDiv.style.display === "none") {
              hiddenDiv.style.display = "block";
              this.textContent = "Show Less";
            } else {
              hiddenDiv.style.display = "none";
              this.textContent = "Show More";
            }
          });
        }
      },
       saveEditedRoster: function(){
        try{
          const rosterTable = document.getElementById("editableRoster");
          if(!rosterTable){
            this.showError("No roster table found.");
            return;
          }

          // 1. Get the current Staff List
          const staffList = this.getCurrentStaffList();

          // 2. Clear existing assignments for all staff *not* locked.
          staffList.forEach(staff => {
            if(!staff.locked) staff.assigned = [];  // Reset assignments for unlocked staff
          });

          // 3. Iterate over the EDITED roster table
          const rows = rosterTable.querySelectorAll("tbody tr");
          rows.forEach(row => {
            const location = row.getAttribute("data-loc");
            const cells = row.querySelectorAll("td[data-slot]");

            cells.forEach(cell => {
              const slot = cell.getAttribute("data-slot");
              const staffIDs = cell.textContent.split((location==="Pass Counter"||location==="Lobby")?" | ":",").map(id => id.trim()).filter(Boolean);

              staffIDs.forEach(staffID => {
                //Find staff in the staffList
                const staff = staffList.find(s => s.staffID === staffID);

                // *CRUCIAL*: Only re-assign if ATTENDING and NOT LOCKED.
                if(staff && staff.attendance === "Yes" && !staff.locked){
                  staff.assigned.push({slot, location});
                }
              });
            });
          });

          // 4. Apply Changes and Re-validate/Display:
          this.applyStaffListToTable(staffList); //apply changes to the staff table on UI
          this.saveAssignedToRows(staffList); // This ALSO saves to localStorage
          const gapThreshold = parseInt(document.getElementById("gapThreshold").value,10) || 120;
          const {issues, conflicts} = this.validateRoster(this.getEditableRosterData(), gapThreshold); // re-validate using NEW data
          this.lastValidationConflicts = conflicts; //store updated conflicts.
          this.displayNotes(issues); //display any errors.
          this.displayRoster(this.getEditableRosterData(), conflicts, new Date()); // Re-display with updated conflicts

          this.showSuccess("Roster edits saved successfully!");
        } catch(error){
          console.error("Error saving roster edits:", error);
          this.showError("Failed to save roster edits: " + error.message);
        }
      },
      getEditableRosterData: function() {
        const rosterTable = document.getElementById("editableRoster");
        if (!rosterTable) return {}; // Return empty object if no table

        const roster = {};
        const rows = rosterTable.querySelectorAll("tbody tr");
        rows.forEach(row => {
          const location = row.getAttribute("data-loc");
          roster[location] = {};
          const cells = row.querySelectorAll("td[data-slot]");
          cells.forEach(cell => {
            const slot = cell.getAttribute("data-slot");
            roster[location][slot] = cell.textContent.trim();
          });
        });
        return roster;
      },
      getTableData: function() {
        const rosterTable = document.getElementById("editableRoster");
        if (!rosterTable) return []; // Return empty array if no table

        const data = [];
        rosterTable.querySelectorAll("tr").forEach(row => {
          const rowData = [];
          row.querySelectorAll("th, td").forEach(cell => {
            rowData.push(cell.textContent.trim());
          });
          data.push(rowData);
        });
        return data;
      },

 /******************** Export Functions ********************/
      copyTSV: function() {
        const tableData = this.getTableData();
        const tsv = tableData.map(row => row.join("\t")).join("\n");
        navigator.clipboard.writeText(tsv).then(() => this.showSuccess("Roster copied as TSV."), () => this.showError("Failed to copy TSV."));
      },
      downloadRoster: function(format) {
        if (format === "csv") this.downloadAsCSV();
        else if (format === "pdf") this.downloadAsPDF();
      },
    downloadAsCSV: function() {
        const tableData = this.getTableData();
        const rosterDate = document.getElementById("rosterDate").value;
        const dayValue = document.getElementById("rosterDay").value;
        const creationTime = new Date().toLocaleString();

        // Add a header row to the CSV data
        const headerRow = [`Roster Date: ${rosterDate} (${dayValue})`, `Generated: ${creationTime}`];
        const csvData = [headerRow, ...tableData].map(row => row.join(",")).join("\n");

        const blob = new Blob([csvData], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const date = new Date().toISOString().split("T")[0];
        link.href = url;
        link.download = `roster_${date}.csv`;
        link.click();
        URL.revokeObjectURL(url);
        this.showSuccess("CSV file downloaded successfully.");
    },
    downloadAsPDF: function() {
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        const rosterDate = document.getElementById("rosterDate").value;
        const dayValue = document.getElementById("rosterDay").value;
        const creationTime = new Date().toLocaleString();

        // --- Title and Header ---
        doc.setFontSize(16);
        doc.text(`Staff Roster - ${rosterDate} (${dayValue})`, 14, 20);
        doc.setFontSize(10);
        doc.text(`Generated: ${creationTime}`, 14, 28);  // Adjusted y-coordinate


        const tableData = this.getTableData();

        // --- Main Roster Table ---
        doc.autoTable({
            head: [tableData[0]], // Header row
            body: tableData.slice(1), // Data rows
            startY: 36,  // Start below the title and generation time
            margin: { top: 36 }, // Ensure enough space
            styles: {
                halign: 'center',
                valign: 'middle',
                cellPadding: 2, // Reduced padding
                fontSize: 9,
                lineColor: [0, 0, 0], // Black border
                lineWidth: 0.5, // Thicker border
            },
            headStyles: {
                fillColor: [108, 117, 125], // Grey background
                textColor: 255, // White text
                halign: 'center',
                fontStyle: 'bold',
            },
            columnStyles: {
                0: { cellWidth: 80 }, // Location column wider
               // 1: { cellWidth: 20 }, // Example: Adjust other columns as needed
               // 2: { cellWidth: 20 },
               // ... and so on for all columns
            },
            // Remove "Not applicable text"
            didParseCell: function (data) {
                const cell = data.cell;
                if (cell.raw && cell.raw.includes && cell.raw.includes('Not applicable')) {
                  data.cell.text = '';
                }
            },

             // Add thin lines *within* cells for multiple staff
            didDrawCell: function(data) {
                if (data.section === 'body' && data.column.index !== 0) { // Skip location column
                    const cell = data.cell;
                    const lines = cell.text;
                    if (lines.length > 1) { // Multiple staff
                        let y = cell.y + cell.padding('top');
                        for (let i = 1; i < lines.length; i++) {
                            y += cell.textLineHeight; // Move down to the next line position
                            doc.setLineWidth(0.1); // Thinner line
                            doc.line(cell.x, y, cell.x + cell.width, y); // Horizontal line
                        }
                        doc.setLineWidth(0.5); //restore to normal width
                    }
                }
            }

        });

        // --- Break Time List ---
        const breakListData = this.getCurrentStaffList()
                                  .filter(staff => staff.attendance === "Yes")
                                   //Modify output format
                                  .map(staff => `${staff.staffID} (${staff.name}): ${staff.breakTime}`);

        if (breakListData.length > 0) {
            const breakListX = 14; // Left margin
            let breakListY = doc.autoTable.previous.finalY + 10; // Start below the main table

            doc.setFontSize(12);
            doc.text("Staff Break Times", breakListX, breakListY);
            breakListY += 5;
            doc.setFontSize(10);

            breakListData.forEach(item => {
              doc.text(item, breakListX, breakListY);
              breakListY += 5; // Fixed vertical spacing
                 // Check if we need a new page
                if (breakListY > 280) { // Assuming A4 page height is about 297mm
                    doc.addPage();
                    breakListY = 20; // Reset Y position for the new page
                 }

            });
        }


        const date = new Date().toISOString().split("T")[0];
        doc.save(`roster_${date}.pdf`);
        this.showSuccess("PDF file downloaded successfully.");
    } catch (e) {
        console.error("PDF download error:", e);
        this.showError("Failed to download PDF: " + e.message);
    }
},
 /******************** Utility Functions ********************/
    timeToMinutes: function(timeStr) {
        if (!timeStr || !/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(timeStr)) {
            console.warn("Invalid time format:", timeStr);
            return 0; // Or throw an error, depending on your needs
        }
        let [hours, minutes] = timeStr.split(":").map(Number);
        // Adjust for the 20:00 start time.  Times before 08:00 are considered next-day.
        if (hours < 8) {
            hours += 24; // Add 24 hours to shift to the next day
        }
        return (hours - 20) * 60 + minutes;
    },

    locationApplies: function(loc, slot, isWeekend) {
        //Tango Papa only at 07:00
        if(loc === "Tango Papa") return slot === "07:00";

        //Vertical Patrol only at specific times.
        if(loc === "Vertical Patrol") {
            return ["20:30", "23:00", "01:30", "06:00"].includes(slot);
        }
        if (slot === "06:30" && loc !== "Vertical Patrol") return false;
        if (slot === "07:00" && loc !== "Tango Papa") return false;
        if (loc === "Report Room" && isWeekend) return false;

        return true; // All other locations/slots are valid
      },
      parseBreakTime: function(breakTime) {
        if (!breakTime || !breakTime.includes("-")) return {
          start: 0,
          end: 0
        };
        const [start, end] = breakTime.split("-");
        return {
          start: this.timeToMinutes(start),
          end: this.timeToMinutes(end)
        };
      },
    };

    // Expose rosterSystem globally (if needed)
    window.RosterApp = rosterSystem;

    /**************************************************************
     * DOMContentLoaded: Initialize the system once the DOM is ready.
     * This ensures all elements exist before any event bindings are applied.
     **************************************************************/
    document.addEventListener("DOMContentLoaded", () => {
      rosterSystem.init();
    });
  </script>
</body>
</html>
