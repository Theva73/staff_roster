<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Staff Roster Management System</title>
  
  <!-- External libraries (NO XLSX) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>

  <style>
    /* (Your CSS remains unchanged) */
    body { 
      font-family: Arial, sans-serif; 
      padding: 20px; 
      text-align: center;
      font-size: 14px;
      background-color: #f3f4f6;
      margin: 0; 
    }
    /* … additional styles … */
  </style>
</head>

<body>
  <h2>Staff Roster Management System</h2>
  <!-- (HTML body content remains unchanged) -->

  <script>
    /************************************************************
     * Roster System WITHOUT XLSX. We removed all references to
     * the XLSX library and the "Excel" button.
     ************************************************************/

    // Core constants and variables remain the same...
    const STORAGE_KEY = 'staffListData';
    const ROSTER_TIMES = [ "20:00", "20:30", "21:00", "22:00", "23:00",
      "00:00", "01:00", "01:30", "02:00", "03:00",
      "04:00", "05:00", "06:00", "07:00", "07:30" ];
    const PRIORITY = [
      { location: "Pass Counter", needed: 2 },
      { location: "HHMD", needed: 1 },
      { location: "Lobby", needed: 2 },
      { location: "Guard House", needed: 1 },
      { location: "Vertical Patrol", needed: 1 },
      { location: "Report Room", needed: 1 },
      { location: "Tango Papa", needed: 1 }
    ];
    const OUTPUT_ORDER = [
      "Pass Counter", "HHMD", "Lobby", "Guard House",
      "Vertical Patrol", "Report Room", "Tango Papa"
    ];
    const BREAK_TIME_POOL = [
      "20:00-21:30", "21:30-23:30", "22:00-00:00",
      "23:00-01:00", "00:00-02:00", "01:30-03:30",
      "02:00-04:00", "03:00-05:00", "04:00-06:00",
      "05:00-07:00", "06:00-08:00"
    ];
    const CRITICAL_LOCATIONS = {
      "Vertical Patrol": ["20:30", "23:00", "01:30", "06:00"],
      "Report Room": ["20:00", "21:00"],
      "Tango Papa": ["07:30"]
    };

    // Roster system object with patch fixes integrated
    const rosterSystem = {
      init: function() {
        // ... (initialization code remains unchanged) ...
        const requiredElements = [ 'rosterDate', 'rosterDay', 'gapThreshold', 'staffCount', 'staffTable',
            'addStaffBtn', 'importDataBtn', 'exportDataBtn', 'shuffleBreaksBtn',
            'generateRosterBtn', 'copyTSVBtn', 'downloadCSVBtn', 'downloadPDFBtn',
            'toggleBreakNoteBtn', 'importFile', 'rosterContainer', 'notesContainer',
            'breakListContainer' ];
        let missingElements = [];
        requiredElements.forEach(id => {
          if (!document.getElementById(id)) { missingElements.push(id); }
        });
        if (missingElements.length > 0) { console.error("Missing HTML elements:", missingElements); return; }
        if (typeof jsPDF === "undefined") { console.error("jsPDF library failed to load (needed for PDF export)"); }
        // Set date and day
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('rosterDate').value = today;
        const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
        document.getElementById('rosterDay').value = days[new Date().getDay()];
        // Gap threshold slider listeners
        const gapSlider = document.getElementById("gapThreshold");
        const gapDisplay = document.getElementById("gapThresholdValue");
        gapSlider.addEventListener("input", function() { gapDisplay.innerText = this.value; });
        gapSlider.addEventListener("change", () => { rosterSystem.generateRoster(); });
        // Button event listeners
        document.getElementById('addStaffBtn').addEventListener('click', () => this.addStaff());
        document.getElementById('importDataBtn').addEventListener('click', () => this.importData());
        document.getElementById('exportDataBtn').addEventListener('click', () => this.exportData());
        document.getElementById('shuffleBreaksBtn').addEventListener('click', () => this.shuffleBreakTimes());
        document.getElementById('generateRosterBtn').addEventListener('click', () => this.generateRoster());
        document.getElementById('copyTSVBtn').addEventListener('click', () => this.copyTSV());
        document.getElementById('downloadCSVBtn').addEventListener('click', () => this.downloadRoster('csv'));
        document.getElementById('downloadPDFBtn').addEventListener('click', () => this.downloadRoster('pdf'));
        document.getElementById('toggleBreakNoteBtn').addEventListener('click', this.toggleBreakNote);
        this.makeDraggable(document.getElementById('breakListContainer'));
        this.loadStaffList();
      },

      // Updated getCurrentStaffList – patch fix version (keeping all your properties)
      getCurrentStaffList: function() {
        const rows = document.getElementById("staffTable").querySelector("tbody").rows;
        const staffList = [];
        for (let row of rows) {
          const timeInputs = row.cells[2].querySelectorAll("input[type='time']");
          const startInput = timeInputs[0].value.padEnd(5, ":00");
          const endInput = timeInputs[1].value.padEnd(5, ":00");
          // Enforce proper break time format
          const breakTime = `${startInput}-${endInput}`.replace(/:+/g, ":");
          const staffData = {
            staffID: row.cells[0].querySelector("input").value.trim(),
            name: row.cells[1].querySelector("input").value.trim(),
            breakTime: breakTime,
            hhmdEligible: row.cells[3].querySelector("select").value,
            attendance: row.cells[4].querySelector("select").value,
            locked: row.cells[5].querySelector("input[type='checkbox']").checked,
            assigned: row.dataset.assigned ? JSON.parse(row.dataset.assigned) : []
          };
          staffList.push(staffData);
        }
        return staffList;
      },

      // Updated isOnBreak – comment now reads "Normalize break time format"
      isOnBreak: function(st, slot) {
        if (!st.breakTime) return false;
        // Normalize break time format
        const cleanBreak = st.breakTime
          .replace(/:/g, "-") // Replace colons with hyphens
          .replace(/(\d{2})-(\d{2})/g, "$1:$2"); // Restore time format
        const [bStart, bEnd] = cleanBreak.split("-").map(t => t.trim().padEnd(5, ":00").substring(0, 5));
        const slotTime = this.timeToMinutes(slot);
        const breakStart = this.timeToMinutes(bStart);
        const breakEnd = this.timeToMinutes(bEnd);
        // Handle overnight breaks
        if (breakStart > breakEnd) {
          return slotTime >= breakStart || slotTime <= breakEnd;
        }
        return slotTime >= breakStart && slotTime <= breakEnd;
      },

      // Updated validateRoster – enhanced gap checking with consecutive assignment check per patch fixes
      validateRoster: function(roster, gapThreshold = 120) {
        const staffAssignments = {};
        const issues = [];
        const conflicts = {};
        // Helper function to record conflicts
        function addConflict(loc, slot, staffID, conflictType) {
          if (!conflicts[loc]) conflicts[loc] = {};
          if (!conflicts[loc][slot]) conflicts[loc][slot] = {};
          if (!conflicts[loc][slot][staffID]) conflicts[loc][slot][staffID] = [];
          conflicts[loc][slot][staffID].push(conflictType);
        }
        // Existing validation logic – iterate over roster and build staffAssignments
        const staffList = this.getCurrentStaffList();
        for (const loc in roster) {
          for (const slot in roster[loc]) {
            const staffListStr = roster[loc][slot];
            if (!staffListStr) continue;
            if (slot === "07:30" && loc !== "Tango Papa") {
              const staffIDs = staffListStr.split(",").map(s => s.trim()).filter(Boolean);
              staffIDs.forEach(staffID => {
                issues.push(`Staff ${staffID} assigned at ${loc} for 07:30, which is reserved for Tango Papa only`);
                addConflict(loc, slot, staffID, "invalid0730");
              });
              continue;
            }
            const staffIDs = staffListStr.split(",").map(s => s.trim()).filter(Boolean);
            const uniqueStaffIDs = new Set(staffIDs);
            if (uniqueStaffIDs.size < staffIDs.length) {
              const duplicates = staffIDs.filter((id, index) => staffIDs.indexOf(id) !== index);
              duplicates.forEach(id => {
                issues.push(`Staff ${id} listed multiple times at ${loc} for ${slot}`);
                addConflict(loc, slot, id, "duplicateAssignment");
              });
            }
            for (const staffID of staffIDs) {
              const staff = staffList.find(s => s.staffID === staffID);
              if (staff && this.isOnBreak(staff, slot)) {
                issues.push(`Staff ${staffID} assigned at ${loc} during break at ${slot}`);
                addConflict(loc, slot, staffID, "breakViolation");
              }
              if (!staffAssignments[staffID]) staffAssignments[staffID] = [];
              const existing = staffAssignments[staffID].find(a => a.slot === slot);
              if (existing) {
                issues.push(`Staff ${staffID} double-booked at ${slot}: ${existing.location} and ${loc}`);
                addConflict(loc, slot, staffID, "doubleBooked");
                addConflict(existing.location, slot, staffID, "doubleBooked");
              }
              staffAssignments[staffID].push({ slot, location: loc });
            }
          }
        }
        // New: Enhanced consecutive assignment check (requires at least a 1‑hour gap)
        for (const staffID in staffAssignments) {
          const assignments = staffAssignments[staffID].sort((a, b) =>
            this.timeToMinutes(a.slot) - this.timeToMinutes(b.slot)
          );
          for (let i = 0; i < assignments.length - 1; i++) {
            const current = assignments[i];
            const next = assignments[i + 1];
            if (current.location === next.location) {
              const timeDiff = this.timeToMinutes(next.slot) - this.timeToMinutes(current.slot);
              if (timeDiff <= 60) { // 1 hour gap minimum
                issues.push(`Staff ${staffID} has consecutive assignments at ${current.location}: ${current.slot} → ${next.slot}`);
                addConflict(current.location, current.slot, staffID, "consecutive");
                addConflict(next.location, next.slot, staffID, "consecutive");
              }
            }
          }
        }
        return { issues, conflicts };
      },

      // Updated downloadAsPDF – fix for break time display formatting
      downloadAsPDF: function(rosterData, breakData) {
        const formattedBreakData = breakData.map(row => {
          if (row[2]) { row[2] = row[2].replace(/(\d{2}:\d{2})-(\d{2}:\d{2})/, "$1 to $2"); }
          return row;
        });
        const { jsPDF } = window.jspdf;
        if (!jsPDF) { alert("jsPDF library not found. PDF export not available."); return; }
        const doc = new jsPDF('landscape', 'pt', 'a4');
        const rosterDate = document.getElementById("rosterDate").value;
        const creationTime = new Date().toLocaleString();
        doc.setFontSize(10);
        doc.text(`Roster Date: ${rosterDate} | Generated on: ${creationTime}`, 40, 20);
        doc.text("Roster", 40, 40);
        doc.autoTable({
          startY: 50,
          head: [rosterData[0]],
          body: rosterData.slice(1),
          margin: { left: 40 },
          theme: 'grid',
          styles: { fontSize: 8 },
          headStyles: { fillColor: [41, 128, 185] }
        });
        let finalY = doc.lastAutoTable.finalY + 20;
        doc.text("Staff Break Times", 40, finalY);
        doc.autoTable({
          startY: finalY + 10,
          head: [formattedBreakData[0]],
          body: formattedBreakData.slice(1),
          margin: { left: 40 },
          theme: 'striped',
          styles: { fontSize: 8, cellPadding: 4 },
          columnStyles: { 0: { cellWidth: 80 }, 1: { cellWidth: 100 }, 2: { cellWidth: 80 } },
          headStyles: { fillColor: [52, 152, 219] }
        });
        doc.save("Roster_with_Breaks.pdf");
      },

      // ... (the rest of your functions such as addStaff, removeRow, generateRoster, importData, exportData, etc. remain unchanged) ...

      makeDraggable: function(el) {
        let pos = { top: 0, left: 0, x: 0, y: 0 };
        const mouseDownHandler = function(e) {
          pos = { left: el.offsetLeft, top: el.offsetTop, x: e.clientX, y: e.clientY };
          document.addEventListener('mousemove', mouseMoveHandler);
          document.addEventListener('mouseup', mouseUpHandler);
        };
        const mouseMoveHandler = function(e) {
          const dx = e.clientX - pos.x;
          const dy = e.clientY - pos.y;
          el.style.left = pos.left + dx + 'px';
          el.style.top = pos.top + dy + 'px';
        };
        const mouseUpHandler = function() {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
        };
        el.addEventListener('mousedown', mouseDownHandler);
      }
    };

    // Attach rosterSystem to global scope
    window.RosterApp = rosterSystem;
    // Initialize when document is ready
    document.addEventListener('DOMContentLoaded', () => rosterSystem.init());
  </script>
</body>
</html>