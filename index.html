<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Staff Roster Management System CP - Fixed</title>
  <!-- External Libraries for PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>
  <style>
    /* =================== Global Style Variables =================== */
    :root {
      --primary-color: #4f46e5;
      --primary-hover: #4338ca;
      --button-color: #6c757d; 
      --button-hover: #5a6268; 
      --button-active: #545b62; 
      --secondary-color: #6B7280;
      --success-color: #10B981;
      --warning-color: #F59E0B;
      --danger-color: #EF4444;
      --light-bg: #f8f9fa;
      --border-color: #dee2e6;
      --text-color: #343a40;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.5;
      text-align: center;
    }
    h2 { margin-bottom: 25px; font-weight: 600; }
    h3, h4 { margin: 20px 0 10px; }
    .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }
    .card {
      background: #fff; border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 20px; margin-bottom: 20px;
      border: 1px solid var(--border-color);
    }
    .date-container, .gap-policy-container {
      margin: 20px 0; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;
    }
    .date-container > div, .gap-policy-container > div {
      display: flex; align-items: center; gap: 8px;
    }
    table {
      width: 100%; border-collapse: collapse; margin: 20px 0;
      background: #fff; border-radius: 6px; overflow: hidden;
    }
    th, td {
      border: 1px solid var(--border-color); padding: 10px 8px; text-align: center;
    }
    th { background-color: var(--light-bg); font-weight: 600; }
    tr:nth-child(even) { background-color: rgba(0,0,0,0.05); }
    tr:hover { background-color: rgba(0,0,0,0.075); }
    #rosterContainer { overflow-x: auto; }
    #editableRoster thead th:first-child,
    #editableRoster tbody td:first-child {
      position: sticky; left: 0; background: #fff; z-index: 10;
    }
    input, select {
      padding: 8px 12px; text-align: center;
      font-size: 14px; border: 1px solid var(--border-color);
      border-radius: 4px; transition: border-color 0.2s;
      background-color: #fff; color: var(--text-color);
    }
    input::placeholder, select::placeholder { color: #6c757d; }
    input:focus, select:focus {
      outline: none; border-color: var(--button-color);
      box-shadow: 0 0 0 2px rgba(108,117,125,0.25);
    }
    input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
    /* =================== Buttons: Shortened & 2-per-row on mobile =================== */
    .button-container { display: flex; flex-direction: column; gap: 12px; margin: 20px 0; align-items: center; }
    .button-row { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
    .roster-btn {
      background-color: var(--button-color);
      color: #fff;
      padding: 6px 12px;
      font-size: 13px;
      border-radius: 4px;
      border: none; cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      white-space: nowrap;
    }
    .roster-btn:hover { background-color: var(--button-hover); transform: translateY(-1px); }
    .roster-btn:active { background-color: var(--button-active); transform: translateY(1px); box-shadow: none; }
    @media (max-width: 768px) {
      .button-row {
        flex-direction: row; flex-wrap: wrap; justify-content: space-between;
        width: 100%; max-width: 320px;
      }
      .roster-btn { flex: 1 1 45%; margin-bottom: 8px; }
    }
    /* =================== Floating Break List =================== */
    #breakListContainer {
      position: fixed; bottom: 20px; left: 20px; width: 240px; max-height: 350px; overflow: auto;
      background: #fff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 15px; font-size: 13px; text-align: left; cursor: move; z-index: 1000;
      border: 1px solid var(--border-color); transition: opacity 0.3s;
    }
    #breakListContainer.hidden { opacity: 0.2; }
    #breakListContainer:hover { opacity: 1; }
    /* =================== Notifications =================== */
    #notification-container {
      position: fixed; top: 10px; right: 10px; z-index: 1001;
    }
    .notification {
      padding: 10px; margin-bottom: 5px; border-radius: 4px; min-width: 200px;
    }
    .notification.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .notification.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .notification.warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
    .notification.info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    /* =================== Roster Health Notes =================== */
    .status-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
    .status-success { background-color: var(--success-color); }
    .status-warning { background-color: var(--warning-color); }
    .status-danger { background-color: var(--danger-color); }
  </style>
</head>
<body>
  <div class="container">
    <h2>Staff Roster Management System CP</h2>
    <!-- Date & Gap Policy -->
    <div class="card">
      <div class="date-container">
        <div>
          <label for="rosterDate">Roster Date:</label>
          <input type="date" id="rosterDate">
        </div>
        <div>
          <label for="rosterDay">Day:</label>
          <select id="rosterDay">
            <option value="Monday">Monday</option>
            <option value="Tuesday">Tuesday</option>
            <option value="Wednesday">Wednesday</option>
            <option value="Thursday">Thursday</option>
            <option value="Friday">Friday</option>
            <option value="Saturday">Saturday</option>
            <option value="Sunday">Sunday</option>
          </select>
        </div>
        <div>
          <label>Working Staff:</label>
          <span id="staffCount">0</span>
        </div>
      </div>
      <div class="gap-policy-container">
        <div>
          <label for="gapThreshold">Gap Threshold (minutes):</label>
          <input type="range" id="gapThreshold" min="30" max="120" step="15" value="120">
          <span id="gapThresholdValue">120</span>
        </div>
      </div>
    </div>
    <!-- Staff Management Table & Buttons -->
    <div class="card">
      <h3>Staff Management</h3>
      <table id="staffTable">
        <thead>
          <tr>
            <th>Staff ID</th>
            <th>Name</th>
            <th>Break Time</th>
            <th>HHMD Eligible</th>
            <th>Attendance</th>
            <th>Lock</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows inserted dynamically -->
        </tbody>
      </table>
      <div class="button-container">
        <div class="button-row">
          <button class="roster-btn" id="addStaffBtn">Add Staff</button>
          <button class="roster-btn" id="importDataBtn">Import</button>
          <button class="roster-btn" id="exportDataBtn">Export</button>
        </div>
        <div class="button-row">
          <button class="roster-btn" id="shuffleBreaksBtn">Shuffle</button>
          <button class="roster-btn" id="generateRosterBtn">Generate</button>
          <button class="roster-btn" id="copyTSVBtn">Copy</button>
        </div>
        <div class="button-row">
          <button class="roster-btn" id="downloadCSVBtn">CSV</button>
          <button class="roster-btn" id="downloadPDFBtn">PDF</button>
          <button class="roster-btn" id="toggleBreakNoteBtn">Break Note</button>
        </div>
      </div>
    </div>
    <input type="file" id="importFile" accept=".json" style="display:none;" />
    <!-- Generated Roster -->
    <div class="card">
      <h3>Generated Roster</h3>
      <div id="rosterContainer"></div>
    </div>
    <!-- Roster Health -->
    <div class="card">
      <h4>Roster Health</h4>
      <div id="notesContainer"></div>
    </div>
  </div>
  <!-- Floating Break List (Draggable) -->
  <div id="breakListContainer">
    <strong>Staff Break Times</strong><br><br>
    <!-- Populated dynamically -->
  </div>
  <div id="notification-container"></div>
  <script>
    /**************************************************************
     * Global Constants and Variables
     **************************************************************/
    const STORAGE_KEY = 'staffListData_v2';
    // CHANGED: Updated break time intervals (from your screenshot)
    const BREAK_TIME_POOL = [
      "22:00-00:00",
      "00:00-02:00",
      "02:00-04:00",
      "04:00-06:00",
      "05:00-07:00",
      "06:00-08:00"
    ];
    const ROSTER_TIMES = ["20:00","20:30","21:00","22:00","23:00","00:00","01:00","01:30","02:00","03:00","04:00","05:00","06:00","07:00"];
    const PRIORITY = [
      { location: "Pass Counter", needed: 2 },
      { location: "HHMD", needed: 1 },
      { location: "Lobby", needed: 2 },
      { location: "Guard House", needed: 1 },
      { location: "Vertical Patrol", needed: 1 },
      { location: "Report Room", needed: 1 },
      { location: "Tango Papa", needed: 1 }
    ];
    const OUTPUT_ORDER = ["Pass Counter","HHMD","Guard House","Lobby","Report Room","Vertical Patrol","Tango Papa"];
    const CRITICAL_LOCATIONS = {
      "Vertical Patrol": ["20:30", "23:00", "01:30", "06:30"],
      "Report Room": ["20:00", "21:00"],
      "Tango Papa": ["07:00"]
    };

    /**************************************************************
     * The Roster System Object
     **************************************************************/
    const rosterSystem = {
      generatedRosterData: null,
      lastValidationConflicts: {},
      
      init: function() {
        console.log("Initializing roster system...");
        this.initializeDateAndDay();
        this.setupEventListeners();
        this.makeDraggable(document.getElementById('breakListContainer'));
        this.loadStaffList();
        this.displayBreakList();
        this.showSuccess("System initialized successfully.");
      },
      
      initializeDateAndDay: function() {
        const today = new Date();
        document.getElementById('rosterDate').value = today.toISOString().split('T')[0];
        const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
        document.getElementById('rosterDay').value = days[today.getDay()];
      },
      
      setupEventListeners: function() {
        const gapSlider = document.getElementById("gapThreshold");
        const gapDisplay = document.getElementById("gapThresholdValue");
        gapSlider.addEventListener("input", () => { gapDisplay.innerText = gapSlider.value; });
        gapSlider.addEventListener("change", () => { if(this.generatedRosterData) this.generateRoster(); });
        document.getElementById("addStaffBtn").addEventListener("click", () => this.addStaff());
        document.getElementById("importDataBtn").addEventListener("click", () => this.importData());
        document.getElementById("exportDataBtn").addEventListener("click", () => this.exportData());
        document.getElementById("shuffleBreaksBtn").addEventListener("click", () => this.shuffleBreakTimes());
        document.getElementById("generateRosterBtn").addEventListener("click", () => this.generateRoster());
        document.getElementById("copyTSVBtn").addEventListener("click", () => this.copyTSV());
        document.getElementById("downloadCSVBtn").addEventListener("click", () => this.downloadRoster('csv'));
        document.getElementById("downloadPDFBtn").addEventListener("click", () => this.downloadRoster('pdf'));
        document.getElementById("toggleBreakNoteBtn").addEventListener("click", () => this.toggleBreakNote());
        document.getElementById("rosterDay").addEventListener("change", () => { if(this.generatedRosterData) this.generateRoster(); });
      },
      
      makeDraggable: function(el) {
        if(!el) return;
        let pos = { top: 0, left: 0, x: 0, y: 0 };
        const mouseDownHandler = (e) => {
          pos = { left: el.offsetLeft, top: el.offsetTop, x: e.clientX, y: e.clientY };
          document.addEventListener('mousemove', mouseMoveHandler);
          document.addEventListener('mouseup', mouseUpHandler);
          el.style.cursor = 'grabbing';
          el.style.userSelect = 'none';
        };
        const mouseMoveHandler = (e) => {
          const dx = e.clientX - pos.x, dy = e.clientY - pos.y;
          let newLeft = pos.left + dx, newTop = pos.top + dy;
          const maxX = window.innerWidth - el.offsetWidth, maxY = window.innerHeight - el.offsetHeight;
          newLeft = Math.max(0, Math.min(newLeft, maxX));
          newTop = Math.max(0, Math.min(newTop, maxY));
          el.style.left = newLeft + 'px';
          el.style.top = newTop + 'px';
        };
        const mouseUpHandler = () => {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
          el.style.cursor = 'grab';
          el.style.userSelect = '';
        };
        el.addEventListener('mousedown', mouseDownHandler);
        el.style.cursor = 'grab';
        el.style.position = 'fixed';
      },
      
      /* Notification Functions */
      showSuccess: function(msg) { this.showNotification(msg, 'success'); },
      showError: function(msg) { this.showNotification(msg, 'error'); },
      showWarning: function(msg) { this.showNotification(msg, 'warning'); },
      showNotification: function(message, type='info') {
        const container = document.getElementById("notification-container");
        const n = document.createElement("div");
        n.className = `notification ${type}`;
        const icons = { success:'âœ…', error:'âŒ', warning:'âš ï¸', info:'â„¹ï¸' };
        n.textContent = icons[type] + " " + message;
        container.appendChild(n);
        setTimeout(() => container.removeChild(n), 4000);
      },
      
      /******************** Staff Management ********************/
      loadStaffList: function() {
        const stored = localStorage.getItem(STORAGE_KEY);
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        tbody.innerHTML = "";
        if(stored) {
          try {
            const staffList = JSON.parse(stored);
            staffList.forEach(st => tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML(st)));
            this.showSuccess(`Loaded ${staffList.length} staff members.`);
          } catch(e) {
            console.error(e);
            this.showWarning("Error loading staff data. Starting empty.");
            this.addStaff();
          }
        } else {
          this.addStaff();
        }
        this.addListenersToAllRows();
        this.updateStaffCount();
      },
      
      saveStaffList: function() {
        try {
          const staffList = this.getCurrentStaffList();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(staffList));
        } catch(e) {
          this.showError("Failed to save staff list: " + e.message);
        }
      },
      
      getCurrentStaffList: function() {
        const rows = document.getElementById("staffTable").querySelector("tbody").rows;
        const staffList = [];
        for(let row of rows) {
          try {
            const timeInputs = row.cells[2].querySelectorAll("input[type='time']");
            const startTime = timeInputs[0].value, endTime = timeInputs[1].value;
            const formatTime = t => {
              if(!t) return "00:00";
              const [h, m] = t.split(":");
              return h.padStart(2,'0') + ":" + m.padStart(2,'0');
            };
            const breakTime = formatTime(startTime) + "-" + formatTime(endTime);
            staffList.push({
              staffID: row.cells[0].querySelector("input").value.trim(),
              name: row.cells[1].querySelector("input").value.trim(),
              breakTime: breakTime,
              hhmdEligible: row.cells[3].querySelector("select").value,
              attendance: row.cells[4].querySelector("select").value,
              locked: row.cells[5].querySelector("input[type='checkbox']").checked,
              assigned: row.dataset.assigned ? JSON.parse(row.dataset.assigned) : []
            });
          } catch(err) { console.error(err); }
        }
        return staffList;
      },
      
      getStaffRowHTML: function(staff = {}) {
        let [startVal, endVal] = ["21:30", "23:30"];
        if(staff.breakTime && staff.breakTime.includes("-")) {
          [startVal, endVal] = staff.breakTime.split("-");
        }
        return `
          <tr data-assigned='${JSON.stringify(staff.assigned || [])}'>
            <td><input type="text" value="${staff.staffID || ''}" placeholder="ID"></td>
            <td><input type="text" value="${staff.name || ''}" placeholder="Name"></td>
            <td>
              <div style="display:flex; gap:3px; align-items:center;">
                <input type="time" value="${startVal}" step="1800">
                <span>-</span>
                <input type="time" value="${endVal}" step="1800">
              </div>
            </td>
            <td>
              <select>
                <option value="Yes" ${staff.hhmdEligible==="Yes"?"selected":""}>Yes</option>
                <option value="No" ${staff.hhmdEligible==="No"?"selected":""}>No</option>
              </select>
            </td>
            <td>
              <select>
                <option value="Yes" ${staff.attendance==="Yes"?"selected":""}>Yes</option>
                <option value="No" ${staff.attendance==="No"?"selected":""}>No</option>
              </select>
            </td>
            <td>
              <input type="checkbox" ${staff.locked?"checked":""}>
            </td>
            <td><button class="remove-btn roster-btn">Remove</button></td>
          </tr>
        `;
      },
      
      addListenersToAllRows: function() {
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        const inputs = tbody.querySelectorAll("input, select");
        inputs.forEach(inp => { inp.onchange = () => { this.saveStaffList(); this.updateStaffCount(); this.displayBreakList(); }; });
        const removeButtons = tbody.querySelectorAll(".remove-btn");
        removeButtons.forEach(btn => {
          btn.onclick = () => {
            const row = btn.closest("tr");
            const staffID = row.cells[0].querySelector("input").value.trim();
            if(!staffID || confirm("Remove staff " + staffID + "?")) {
              row.remove();
              this.saveStaffList();
              this.updateStaffCount();
              this.displayBreakList();
            }
          };
        });
      },
      
      updateStaffCount: function() {
        const staffList = this.getCurrentStaffList();
        const working = staffList.filter(st => st.attendance === "Yes").length;
        const sc = document.getElementById("staffCount");
        sc.textContent = working;
        if(working < 5) { sc.style.color = "red"; sc.title = "Low staff"; }
        else if(working < 8) { sc.style.color = "orange"; sc.title = "Minimal staff"; }
        else { sc.style.color = "green"; sc.title = "Sufficient staff"; }
      },
      
      addStaff: function() {
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML({ breakTime: "22:00-00:00", hhmdEligible: "No", attendance: "Yes" }));
        this.addListenersToAllRows();
        this.saveStaffList();
        this.updateStaffCount();
      },
      
      /******************** Shuffle / Break List ********************/
      shuffleBreakTimes: function() {
        const staffList = this.getCurrentStaffList();
        let changedCount = 0;
        staffList.forEach(st => {
          if(st.attendance === "Yes" && !st.locked) {
            const r = Math.floor(Math.random() * BREAK_TIME_POOL.length);
            st.breakTime = BREAK_TIME_POOL[r];
            changedCount++;
          }
        });
        this.applyStaffListToTable(staffList);
        this.showSuccess(`Shuffled break times for ${changedCount} staff!`);
      },
      
      applyStaffListToTable: function(staffList) {
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        tbody.innerHTML = "";
        staffList.forEach(st => { tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML(st)); });
        this.addListenersToAllRows();
        this.updateStaffCount();
        this.saveStaffList();
        this.displayBreakList();
      },
      
      displayBreakList: function() {
        const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        let html = "<strong>Staff Break Times</strong><br><br>";
        if(!staffList.length) { html += "<em>No staff scheduled</em>"; }
        else {
          staffList.sort((a, b) => this.parseBreakTime(a.breakTime).start - this.parseBreakTime(b.breakTime).start);
          staffList.forEach(st => {
            html += `<strong>${st.staffID || "??"}</strong> (${st.name || "??"}): ${st.breakTime}${st.locked ? " ðŸ”’" : ""}<br>`;
          });
        }
        document.getElementById("breakListContainer").innerHTML = html;
      },
      
      toggleBreakNote: function() {
        document.getElementById("breakListContainer").classList.toggle("hidden");
      },
      
      /******************** Import / Export ********************/
      importData: function() {
        const fileInput = document.getElementById("importFile");
        fileInput.value = "";
        fileInput.onchange = async (e) => {
          const file = e.target.files[0];
          if(!file) return;
          try {
            const text = await file.text();
            const imported = JSON.parse(text);
            if(!Array.isArray(imported)) throw new Error("Invalid JSON array");
            localStorage.setItem(STORAGE_KEY, JSON.stringify(imported));
            this.loadStaffList();
            this.displayBreakList();
            this.showSuccess("Imported data successfully.");
          } catch(err) {
            this.showError("Import error: " + err.message);
          }
        };
        fileInput.click();
      },
      
      exportData: function() {
        try {
          const staffList = this.getCurrentStaffList();
          if(!staffList.length) { this.showWarning("No data to export"); return; }
          const jsonStr = JSON.stringify(staffList, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `staff_data_${new Date().toISOString().split('T')[0]}.json`;
          a.click();
          URL.revokeObjectURL(url);
          this.showSuccess("Exported data successfully.");
        } catch(err) {
          this.showError("Export error: " + err.message);
        }
      },
      
      /******************** Roster Generation & Conflict Resolution ********************/
      generateRoster: function() {
        const dayValue = document.getElementById("rosterDay").value;
        const isWeekend = ["Saturday", "Sunday"].includes(dayValue);
        let staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        if(staffList.length === 0) {
          this.showError("Add staff before generating roster.");
          return;
        }
        staffList.forEach(st => { if(!st.locked) st.assigned = []; });
        let roster = this.initializeRoster();
        let shortfalls = [];
        this.assignCritical(roster, staffList, isWeekend, shortfalls);
        this.checkCriticalShortfalls(roster, isWeekend, shortfalls);
        this.assignNonCritical(roster, staffList, isWeekend, shortfalls);
        this.addBufferStaff(roster, staffList, isWeekend);
        this.generatedRosterData = this.createDisplayData(roster);
        const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
        this.autoCorrect(this.generatedRosterData, staffList, gapThreshold);
        this.saveAssignedToRows(staffList);
        const creationTime = new Date();
        this.displayRoster(this.generatedRosterData, this.lastValidationConflicts, creationTime);
        this.displayNotes(shortfalls);
        this.displayBreakList();
        const healthStatus = shortfalls.length === 0 ? "Optimal roster generated!" : `Roster generated with ${shortfalls.length} issues.`;
        this.showSuccess(healthStatus);
        return { roster: this.generatedRosterData, shortfalls };
      },
      
      initializeRoster: function() {
        let roster = {};
        PRIORITY.forEach(({ location }) => { roster[location] = {}; });
        return roster;
      },
      
      assignCritical: function(roster, staffList, isWeekend, shortfalls) {
        for(const loc in CRITICAL_LOCATIONS) {
          if(loc === "Report Room" && isWeekend) continue;
          for(const slot of CRITICAL_LOCATIONS[loc]) {
            if(!this.locationApplies(loc, slot, isWeekend)) continue;
            if(!roster[loc][slot]) roster[loc][slot] = "";
            let chosen = this.findAvailableStaff(staffList, slot, loc);
            if(chosen) {
              let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
              roster[loc][slot] += (roster[loc][slot] ? separator : "") + chosen.staffID;
              chosen.assigned.push({ slot, location: loc });
            } else {
              chosen = this.findEmergencyStaff(staffList, slot, loc);
              if(chosen) {
                let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
                roster[loc][slot] += (roster[loc][slot] ? separator : "") + chosen.staffID;
                chosen.assigned.push({ slot, location: loc });
                shortfalls.push(`Emergency: ${chosen.staffID} assigned to ${loc} at ${slot}`);
              } else {
                shortfalls.push(`CRITICAL: Could not fill ${loc} at ${slot}`);
              }
            }
          }
        }
        for(const loc in roster) {
          let allEmpty = true;
          for(const slot in roster[loc]) {
            if(roster[loc][slot] && roster[loc][slot].trim() !== "") {
              allEmpty = false;
              break;
            }
          }
          if(allEmpty) shortfalls.push(`CRITICAL: ${loc} has zero assignments.`);
        }
      },
      
      checkCriticalShortfalls: function(roster, isWeekend, shortfalls) {
        const vpTimes = ["20:30", "23:00", "01:30", "06:00"];
        for(let time of vpTimes) {
          if(!roster["Vertical Patrol"][time] || roster["Vertical Patrol"][time].length === 0)
            shortfalls.push(`Missing Vertical Patrol at ${time}`);
        }
        if(!isWeekend) {
          const reportTimes = ["20:00", "21:00"];
          for(let time of reportTimes) {
            if(!roster["Report Room"][time] || roster["Report Room"][time].length === 0)
              shortfalls.push(`Missing Report Room at ${time}`);
          }
        }
        if(!roster["Tango Papa"]["07:00"] || roster["Tango Papa"]["07:00"].length === 0)
          shortfalls.push(`Missing Tango Papa at 07:00`);
        for(const slot of ROSTER_TIMES) {
          if(slot === '07:00') continue;
          const count = roster["Pass Counter"][slot] ? roster["Pass Counter"][slot].split(" | ").filter(Boolean).length : 0;
          if(count < 2) shortfalls.push(`CRITICAL: Pass Counter at ${slot} has ${count}/2 staff`);
        }
        for(const slot of ROSTER_TIMES) {
          if(!roster["HHMD"][slot] || roster["HHMD"][slot].length === 0)
            shortfalls.push(`CRITICAL: HHMD at ${slot} has no staff assigned`);
        }
      },
      
      assignNonCritical: function(roster, staffList, isWeekend, shortfalls) {
        for(let p of PRIORITY) {
          const loc = p.location, needed = p.needed;
          for(let slot of ROSTER_TIMES) {
            if(!this.locationApplies(loc, slot, isWeekend)) continue;
            if(!roster[loc][slot]) roster[loc][slot] = "";
            let separator = (loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ";
            const assignedIDs = roster[loc][slot].split(separator).map(s => s.trim()).filter(Boolean);
            const stillNeeded = needed - assignedIDs.length;
            if(stillNeeded <= 0) continue;
            for(let i = 0; i < stillNeeded; i++) {
              const availableStaff = this.findAvailableStaff(staffList, slot, loc);
              if(availableStaff && !this.wouldCauseConflict(roster, availableStaff, slot, loc)) {
                roster[loc][slot] += (roster[loc][slot] ? separator : "") + availableStaff.staffID;
                availableStaff.assigned.push({ slot, location: loc });
              } else {
                if(assignedIDs.length + i === 0) {
                  shortfalls.push(`CRITICAL: No staff available for ${loc} at ${slot}`);
                } else {
                  shortfalls.push(`Shortfall: ${loc} at ${slot} has only ${assignedIDs.length + i}/${needed} staff`);
                }
                break;
              }
            }
          }
        }
      },
      
      addBufferStaff: function(roster, staffList, isWeekend) {
        if(roster["Pass Counter"]) {
          ROSTER_TIMES.forEach(slot => {
            if(!this.locationApplies("Pass Counter", slot, isWeekend)) return;
            if(roster["Pass Counter"][slot]) {
              let visibleAssignments = roster["Pass Counter"][slot].split(" | ").filter(id => !id.includes("*"));
              if(visibleAssignments.length === PRIORITY.find(p => p.location === "Pass Counter").needed) {
                let bufferStaff = this.findAvailableStaff(staffList, slot, "Pass Counter");
                if(bufferStaff && !this.wouldCauseConflict(roster, bufferStaff, slot, "Pass Counter")) {
                  roster["Pass Counter"][slot] += " | " + bufferStaff.staffID + "*";
                  bufferStaff.assigned.push({ slot, location: "Pass Counter", buffer: true });
                }
              }
            }
          });
        }
      },
      
      createDisplayData: function(roster) {
        let displayData = {};
        OUTPUT_ORDER.forEach(loc => {
          displayData[loc] = {};
          ROSTER_TIMES.forEach(slot => {
            let ids = [];
            if(roster[loc] && roster[loc][slot]) {
              let tokens = (loc === "Pass Counter" || loc === "Lobby") ? roster[loc][slot].split(" | ") : roster[loc][slot].split(",");
              ids = tokens.map(s => s.trim()).filter(id => id && !id.includes("*")).sort((a, b) => parseInt(a) - parseInt(b));
            }
            displayData[loc][slot] = (loc === "Pass Counter" || loc === "Lobby") ? ids.join(" | ") : ids.join(", ");
          });
        });
        return displayData;
      },
      
      autoCorrect: function(roster, staffList, gapThreshold) {
        const maxIterations = 20;
        let iteration = 0;
        let { issues, conflicts } = this.validateRoster(roster, gapThreshold);
        this.lastValidationConflicts = conflicts;
        while(issues.length > 0 && iteration < maxIterations) {
          if(!this.autoCorrectRoster(roster, staffList, conflicts)) break;
          ({ issues, conflicts } = this.validateRoster(roster, gapThreshold));
          this.lastValidationConflicts = conflicts;
          iteration++;
        }
        if(issues.length > 0 && gapThreshold > 60) {
          const reducedThreshold = 60;
          iteration = 0;
          while(issues.length > 0 && iteration < maxIterations) {
            if(!this.autoCorrectRoster(roster, staffList, conflicts)) break;
            ({ issues, conflicts } = this.validateRoster(roster, reducedThreshold));
            this.lastValidationConflicts = conflicts;
            iteration++;
          }
          if(issues.length > 0) { shortfalls.push(...issues.filter(issue => !issue.includes("violates"))); }
        } else if(issues.length > 0) {
          shortfalls.push(...issues);
        }
      },
      
      findEmergencyStaff: function(staffList, slot, loc) {
        const availableStaff = staffList.filter(st =>
          st.attendance === "Yes" &&
          !this.isOnBreak(st, slot) &&
          !this.isDoubleBooked(st, slot) &&
          this.locationApplies(loc, slot, document.getElementById("rosterDay").value) &&
          !(loc === "HHMD" && st.hhmdEligible !== "Yes")
        );
        const unlocked = availableStaff.filter(st => !st.locked);
        if(unlocked.length > 0) {
          return unlocked.sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0))[0];
        }
        const locked = availableStaff.filter(st => st.locked);
        if(locked.length > 0) {
          return locked.sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0))[0];
        }
        return null;
      },
      
      findAvailableStaff: function(staffList, slot, loc) {
        const sorted = [...staffList].sort((a, b) => (a.assigned?.length || 0) - (b.assigned?.length || 0));
        for(let st of sorted) {
          if(st.attendance === "Yes" &&
             !this.isOnBreak(st, slot) &&
             !this.isDoubleBooked(st, slot) &&
             !(loc === "HHMD" && st.hhmdEligible !== "Yes") &&
             this.locationApplies(loc, slot, document.getElementById("rosterDay").value)
          ) {
            return st;
          }
        }
        return null;
      },
      
      isOnBreak: function(st, slot) {
        if(!st.breakTime || !st.breakTime.includes("-")) return false;
        if(!/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(st.breakTime)) {
          console.warn("Invalid break time format:", st.staffID, st.breakTime);
          return false;
        }
        const [bStart, bEnd] = st.breakTime.split("-");
        const slotTime = this.timeToMinutes(slot);
        const breakStart = this.timeToMinutes(bStart);
        const breakEnd = this.timeToMinutes(bEnd);
        if(breakStart <= breakEnd) {
          return slotTime >= breakStart && slotTime <= breakEnd;
        } else {
          return slotTime >= breakStart || slotTime <= breakEnd;
        }
      },
      
      isDoubleBooked: function(st, slot) {
        return st.assigned && st.assigned.some(a => a.slot === slot);
      },
      
      wouldCauseConflict: function(roster, staff, slot, loc) {
        if(this.isOnBreak(staff, slot) || this.isDoubleBooked(staff, slot)) return true;
        const potentialAssignments = [...staff.assigned.filter(a => !a.buffer), { slot, location: loc }];
        potentialAssignments.sort((a, b) => ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot));
        const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
        for(let i = 0; i < potentialAssignments.length - 1; i++) {
          const current = potentialAssignments[i];
          const next = potentialAssignments[i + 1];
          if(current.location === next.location) {
            const currentTime = this.timeToMinutes(current.slot);
            const nextTime = this.timeToMinutes(next.slot);
            if(nextTime > currentTime && nextTime - currentTime < gapThreshold) {
              return true;
            }
          }
        }
        return false;
      },
      
      autoCorrectRoster: function(roster, staffList, conflicts) {
        let correctionsMade = false;
        for(let loc in conflicts) {
          for(let slot in conflicts[loc]) {
            for(let staffID in conflicts[loc][slot]) {
              let staff = staffList.find(s => s.staffID === staffID);
              if(staff) {
                this.removeAssignment(roster, staff, slot, loc);
                let current = roster[loc][slot]
                  .split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",")
                  .map(s => s.trim()).filter(Boolean);
                roster[loc][slot] = [...new Set(current)].join((loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ");
                if(slot !== "07:00" || loc === "Tango Papa") {
                  let newStaff = this.findEmergencyStaff(staffList.filter(s => s.staffID !== staffID), slot, loc);
                  if(newStaff && !this.wouldCauseConflict(roster, newStaff, slot, loc) && !this.isOnBreak(newStaff, slot)) {
                    roster[loc][slot] = roster[loc][slot]
                      ? ((loc === "Pass Counter" || loc === "Lobby") ? roster[loc][slot] + " | " + newStaff.staffID : roster[loc][slot] + ", " + newStaff.staffID)
                      : newStaff.staffID;
                    newStaff.assigned.push({ slot, location: loc });
                    correctionsMade = true;
                  } else {
                    correctionsMade = true;
                  }
                } else {
                  correctionsMade = true;
                }
              }
            }
          }
        }
        return correctionsMade;
      },
      
      removeAssignment: function(roster, staff, slot, loc) {
        staff.assigned = staff.assigned.filter(a => !(a.slot === slot && a.location === loc));
        if(roster[loc] && roster[loc][slot]) {
          let ids = roster[loc][slot].split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
          ids = ids.filter(id => id !== staff.staffID);
          roster[loc][slot] = ids.join((loc === "Pass Counter" || loc === "Lobby") ? " | " : ", ");
        }
      },
      
      validateRoster: function(roster, gapThreshold = 120) {
        const staffAssignments = {};
        const issues = [];
        const conflicts = {};
        const staffList = this.getCurrentStaffList();
        function addConflict(loc, slot, staffID, conflictType) {
          if(!conflicts[loc]) conflicts[loc] = {};
          if(!conflicts[loc][slot]) conflicts[loc][slot] = {};
          if(!conflicts[loc][slot][staffID]) conflicts[loc][slot][staffID] = [];
          conflicts[loc][slot][staffID].push(conflictType);
        }
        for(const loc in roster) {
          for(const slot in roster[loc]) {
            const staffStr = roster[loc][slot];
            if(!staffStr) continue;
            if(slot === "07:00" && loc !== "Tango Papa") {
              const staffIDs = staffStr.split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
              staffIDs.forEach(staffID => {
                issues.push(`Staff ${staffID} assigned at ${loc} for 07:00, reserved for Tango Papa`);
                addConflict(loc, slot, staffID, "invalid0700");
              });
              continue;
            }
            const staffIDs = staffStr.split((loc === "Pass Counter" || loc === "Lobby") ? " | " : ",").map(s => s.trim()).filter(Boolean);
            const uniqueIDs = new Set(staffIDs);
            if(uniqueIDs.size < staffIDs.length) {
              const duplicates = staffIDs.filter((id, index) => staffIDs.indexOf(id) !== index);
              duplicates.forEach(id => {
                issues.push(`Staff ${id} listed multiple times at ${loc} for ${slot}`);
                addConflict(loc, slot, id, "duplicateAssignment");
              });
            }
            for(const staffID of staffIDs) {
              const staff = staffList.find(s => s.staffID === staffID);
              if(!staffAssignments[staffID]) staffAssignments[staffID] = [];
              const existing = staffAssignments[staffID].find(a => a.slot === slot);
              if(existing) {
                issues.push(`Staff ${staffID} double-booked at ${slot}: ${existing.location} and ${loc}`);
                addConflict(loc, slot, staffID, "doubleBooked");
                addConflict(existing.location, slot, staffID, "doubleBooked");
              }
              staffAssignments[staffID].push({ slot, location: loc, buffer: false });
            }
          }
        }
        for(const staffID in staffAssignments) {
          const assignments = staffAssignments[staffID].sort((a, b) => ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot));
          for(let i = 0; i < assignments.length - 1; i++) {
            const curr = assignments[i];
            const next = assignments[i + 1];
            if(curr.location === next.location &&
               Math.abs(ROSTER_TIMES.indexOf(curr.slot) - ROSTER_TIMES.indexOf(next.slot)) === 1) {
              issues.push(`Staff ${staffID} has consecutive assignments at ${curr.location}: ${curr.slot} and ${next.slot}`);
              addConflict(curr.location, curr.slot, staffID, "consecutive");
              addConflict(next.location, next.slot, staffID, "consecutive");
            }
            if(curr.location === next.location) {
              const currTime = rosterSystem.timeToMinutes(curr.slot);
              const nextTime = rosterSystem.timeToMinutes(next.slot);
              if(nextTime - currTime < gapThreshold && nextTime - currTime > 0) {
                issues.push(`Staff ${staffID} violates ${gapThreshold/60}-hour gap at ${curr.location}: ${curr.slot} and ${next.slot}`);
                addConflict(curr.location, curr.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
                addConflict(next.location, next.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
              }
            }
          }
        }
        return { issues, conflicts };
      },
      
      saveAssignedToRows: function(staffList) {
        const rows = document.getElementById("staffTable").querySelector("tbody").rows;
        for(let i = 0; i < rows.length; i++) {
          const staffID = rows[i].cells[0].querySelector("input").value.trim();
          const staff = staffList.find(s => s.staffID === staffID);
          if(staff) {
            rows[i].dataset.assigned = JSON.stringify(staff.assigned);
          }
        }
        this.saveStaffList();
      },
      
      displayRoster: function(roster, conflicts, creationTime) {
        const container = document.getElementById("rosterContainer");
        const rosterDate = document.getElementById("rosterDate").value;
        const dayValue = document.getElementById("rosterDay").value;
        let headerHTML = `<div style="text-align:left; margin-bottom:15px; font-size:13px; display:flex; justify-content: space-between; flex-wrap: wrap;">
            <div><strong>Roster Date:</strong> ${rosterDate} (${dayValue})</div>
            <div><strong>Generated:</strong> ${creationTime.toLocaleString()}</div>
        </div>`;
        let tableHTML = `<table id="editableRoster" class="roster-table"><thead><tr><th style="min-width:100px;">Location</th>`;
        ROSTER_TIMES.forEach(slot => tableHTML += `<th>${slot}</th>`);
        tableHTML += `</tr></thead><tbody>`;
        const isWeekend = ["Saturday", "Sunday"].includes(dayValue);
        OUTPUT_ORDER.forEach(loc => {
          tableHTML += `<tr data-loc="${loc}"><td><strong>${loc}</strong></td>`;
          ROSTER_TIMES.forEach(slot => {
            const applies = this.locationApplies(loc, slot, isWeekend);
            let assignedStr = applies ? (roster[loc]?.[slot] || "") : "";
            let staffIDs = (loc === "Pass Counter" || loc === "Lobby") ? assignedStr.split(" | ") : assignedStr.split(",");
            staffIDs = staffIDs.map(s => s.trim()).filter(Boolean);
            let cellStyle = "";
            if(!applies) cellStyle = "background-color:#f8f8f8; color:#999;";
            else if(conflicts[loc] && conflicts[loc][slot]) cellStyle = "background-color:#ffd2d2;";
            else if(applies && !staffIDs.length) cellStyle = "background-color:#ffcccc;";
            else if(CRITICAL_LOCATIONS[loc] && CRITICAL_LOCATIONS[loc].includes(slot)) cellStyle = "background-color:#e2f0ff;";
            tableHTML += `<td contenteditable="true" data-slot="${slot}" style="min-width:80px; ${cellStyle}" title="${applies ? 'Edit' : 'N/A'}">${assignedStr}</td>`;
          });
          tableHTML += "</tr>";
        });
        tableHTML += "</tbody></table>";
        let saveButtonHTML = `<div style="margin-top:15px; text-align:right;"><button class="roster-btn" id="saveEditsBtn">Save Edits</button></div>`;
        container.innerHTML = headerHTML + tableHTML + saveButtonHTML;
        document.getElementById("saveEditsBtn").addEventListener("click", () => this.saveEditedRoster());
        const editableCells = container.querySelectorAll("td[contenteditable='true']");
        editableCells.forEach(cell => {
          cell.addEventListener("focus", () => cell.style.boxShadow = "0 0 0 2px rgba(108,117,125,0.4)");
          cell.addEventListener("blur", () => cell.style.boxShadow = "");
        });
      },
      
      displayNotes: function(shortfalls) {
        const notesContainer = document.getElementById("notesContainer");
        if(shortfalls.length === 0) {
          notesContainer.innerHTML = `<div class="status-message success"><span class="status-indicator status-success"></span> Roster Health: All clear. No issues detected.</div>`;
        } else {
          const visibleCount = 3;
          const visibleNotes = shortfalls.slice(0, visibleCount);
          const hiddenNotes = shortfalls.slice(visibleCount);
          let notesHtml = `<ul class="shortfall-list" style="text-align:left; margin-top:10px; font-size:12px;">`;
          visibleNotes.forEach(note => {
            const style = note.toUpperCase().includes("CRITICAL") ? "color:#EF4444; font-weight:bold;" : "color:#F59E0B;";
            notesHtml += `<li style="${style}">${note}</li>`;
          });
          notesHtml += `</ul>`;
          if(hiddenNotes.length > 0) {
            notesHtml += `<div id="hiddenNotes" style="display:none;"><ul class="shortfall-list" style="text-align:left; margin-top:10px; font-size:12px;">`;
            hiddenNotes.forEach(note => {
              const style = note.toUpperCase().includes("CRITICAL") ? "color:#EF4444; font-weight:bold;" : "color:#F59E0B;";
              notesHtml += `<li style="${style}">${note}</li>`;
            });
            notesHtml += `</ul></div>`;
            notesHtml += `<button id="toggleNotesBtn" class="roster-btn" style="font-size:12px; margin-top:5px;">Show More</button>`;
          }
          notesContainer.innerHTML = `<div class="status-message"><span class="status-indicator status-danger"></span> Roster Health: ${shortfalls.length} issues</div>` + notesHtml;
          document.getElementById("toggleNotesBtn")?.addEventListener("click", function() {
            const hiddenDiv = document.getElementById("hiddenNotes");
            if(hiddenDiv.style.display === "none") { hiddenDiv.style.display = "block"; this.textContent = "Show Less"; }
            else { hiddenDiv.style.display = "none"; this.textContent = "Show More"; }
          });
        }
      },
      
      saveEditedRoster: function() {
        try {
          const rosterTable = document.getElementById("editableRoster");
          if(!rosterTable) { this.showError("No roster table found."); return; }
          const staffList = this.getCurrentStaffList();
          staffList.forEach(staff => { if(!staff.locked) staff.assigned = []; });
          const rows = rosterTable.querySelectorAll("tbody tr");
          rows.forEach(row => {
            const location = row.getAttribute("data-loc");
            const cells = row.querySelectorAll("td[data-slot]");
            cells.forEach(cell => {
              const slot = cell.getAttribute("data-slot");
              const staffIDs = cell.textContent.split((location==="Pass Counter" || location==="Lobby") ? " | " : ",").map(id => id.trim()).filter(Boolean);
              staffIDs.forEach(staffID => {
                const staff = staffList.find(s => s.staffID === staffID);
                if(staff && staff.attendance === "Yes" && !staff.locked) {
                  staff.assigned.push({ slot, location });
                }
              });
            });
          });
          this.applyStaffListToTable(staffList);
          this.saveAssignedToRows(staffList);
          const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
          const { issues, conflicts } = this.validateRoster(this.getEditableRosterData(), gapThreshold);
          this.lastValidationConflicts = conflicts;
          this.displayNotes(issues);
          this.displayRoster(this.getEditableRosterData(), conflicts, new Date());
          this.showSuccess("Roster edits saved successfully!");
        } catch(error) {
          console.error("Error saving roster edits:", error);
          this.showError("Failed to save roster edits: " + error.message);
        }
      },
      
      getEditableRosterData: function() {
        const rosterTable = document.getElementById("editableRoster");
        if(!rosterTable) return {};
        const roster = {};
        const rows = rosterTable.querySelectorAll("tbody tr");
        rows.forEach(row => {
          const location = row.getAttribute("data-loc");
          roster[location] = {};
          const cells = row.querySelectorAll("td[data-slot]");
          cells.forEach(cell => {
            const slot = cell.getAttribute("data-slot");
            roster[location][slot] = cell.textContent.trim();
          });
        });
        return roster;
      },
      
      getTableData: function() {
        const rosterTable = document.getElementById("editableRoster");
        if(!rosterTable) return [];
        const data = [];
        rosterTable.querySelectorAll("tr").forEach(row => {
          const rowData = [];
          row.querySelectorAll("th, td").forEach(cell => {
            rowData.push(cell.textContent.trim());
          });
          data.push(rowData);
        });
        return data;
      },
      
      /******************** Export Functions ********************/
      copyTSV: function() {
        const data = this.getTableData();
        const tsv = data.map(row => row.join("\t")).join("\n");
        navigator.clipboard.writeText(tsv)
          .then(() => this.showSuccess("Copied as TSV"))
          .catch(() => this.showError("Copy failed"));
      },
      
      downloadRoster: function(fmt) {
        if(fmt==="csv") this.downloadAsCSV();
        else if(fmt==="pdf") this.downloadAsPDF();
      },
      
      downloadAsCSV: function() {
        const tableData = this.getTableData();
        const date = document.getElementById("rosterDate").value;
        const day = document.getElementById("rosterDay").value;
        const creation = new Date().toLocaleString();
        const headerRow = [`Roster Date: ${date} (${day})`, `Generated: ${creation}`];
        const csvData = [headerRow, ...tableData].map(r => r.join(",")).join("\n");
        const blob = new Blob([csvData], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `roster_${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        this.showSuccess("CSV downloaded!");
      },
      
      downloadAsPDF: function() {
        try {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF({ unit: 'pt', format: 'A4' });
          const date = document.getElementById("rosterDate").value;
          const day = document.getElementById("rosterDay").value;
          const creation = new Date().toLocaleString();
          doc.setFontSize(14);
          doc.text(`Roster Date: ${date} (${day})`, 40, 40);
          doc.setFontSize(10);
          doc.text(`Generated: ${creation}`, 40, 55);
          const tableData = this.getTableData();
          doc.autoTable({
            head: [ tableData[0] ],
            body: tableData.slice(1),
            startY: 70,
            margin: { left: 40, right: 40 },
            styles: { fontSize: 8, halign: 'center', valign: 'middle', lineWidth: 0.5, lineColor: [0,0,0] },
            headStyles: { fillColor: [108,117,125], textColor: 255, halign: 'center', fontStyle: 'bold' },
            didParseCell: function(data) {
              if(typeof data.cell.text[0] === "string") {
                data.cell.text[0] = data.cell.text[0].replace(/\|/g, "/").trim();
              }
            }
          });
          const staffList = this.getCurrentStaffList();
          const breakRows = staffList.filter(st => st.attendance === "Yes").map(st => [st.staffID, st.name, st.breakTime]);
          if(breakRows.length) {
            const finalY = doc.autoTable.previous.finalY + 30;
            doc.setFontSize(12);
            doc.text("Staff Break Times", 40, finalY);
            doc.autoTable({
              head: [["Staff ID", "Name", "Break Time"]],
              body: breakRows,
              startY: finalY + 10,
              margin: { left: 40, right: 40 },
              styles: { fontSize: 8, halign: 'center', valign: 'middle', lineWidth: 0.5, lineColor: [0,0,0] },
              headStyles: { fillColor: [108,117,125], textColor: 255, halign: 'center', fontStyle: 'bold' }
            });
          }
          doc.save(`roster_${new Date().toISOString().split('T')[0]}.pdf`);
          this.showSuccess("PDF downloaded!");
        } catch(e) {
          console.error(e);
          this.showError("PDF download failed: " + e.message);
        }
      },
      
      parseBreakTime: function(breakTime) {
        if(!breakTime || !breakTime.includes("-")) return { start: 0, end: 0 };
        const [s, e] = breakTime.split("-");
        return { start: this.timeToMinutes(s), end: this.timeToMinutes(e) };
      },
      
      timeToMinutes: function(timeStr) {
        if(!timeStr || !/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(timeStr)) return 0;
        let [hh, mm] = timeStr.split(":").map(Number);
        if(hh < 8) hh += 24;
        return (hh - 20) * 60 + (mm || 0);
      },
      
      locationApplies: function(loc, slot, isWeekend) {
        if(loc === "Tango Papa") return slot === "07:00";
        if(loc === "Vertical Patrol") {
          return ["20:30", "23:00", "01:30", "06:00"].includes(slot);
        }
        if(slot === "06:30" && loc !== "Vertical Patrol") return false;
        if(slot === "07:00" && loc !== "Tango Papa") return false;
        if(loc === "Report Room" && isWeekend) return false;
        return true;
      }
    };

    window.addEventListener("DOMContentLoaded", () => rosterSystem.init());
  </script>
</body>
</html>