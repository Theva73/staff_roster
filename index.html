<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Staff Roster Management System</title>
  
  <!-- External libraries (NO XLSX) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>
  
  <style>
    body { 
      font-family: Arial, sans-serif; 
      padding: 20px; 
      text-align: center;
      font-size: 14px;
      background-color: #f3f4f6;
      margin: 0; 
    }
    h2 { color: #1a1a1a; margin-bottom: 25px; }
    .date-container, .gap-policy-container {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .date-container > div, .gap-policy-container > div {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    table { 
      width: 100%; 
      border-collapse: collapse; 
      margin: 20px 0;
      background: white;
    }
    th, td { 
      border: 1px solid #ddd; 
      padding: 8px; 
      text-align: center; 
    }
    th { background-color: #f4f4f4; }
    input, select { padding: 4px; text-align: center; font-size: 12px; }
    .button-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 12px 0;
      align-items: center;
    }
    .button-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .roster-btn {
      background-color: #6B7280;
      color: white;
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
    }
    .roster-btn:hover { background-color: #4B5563; }
    .remove-btn {
      background-color: #6B7280;
      color: white;
      padding: 1px 6px;
      font-size: 11px;
      border-radius: 3px;
      border: none;
      cursor: pointer;
    }
    .break-time-container { display: flex; align-items: center; gap: 5px; }
    .shortfall-note { color: red; font-weight: bold; font-size: 12px; }
    #importFile { display: none; }
    #rosterContainer { overflow-x: auto; }
    .staff-input, .time-input, .staff-select { font-size: 12px; }
    #breakListContainer {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 180px;
      max-height: 300px;
      overflow: auto;
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 8px;
      font-size: 12px;
      text-align: left;
      cursor: move;
    }
    /* Highlight cells selected for manual review */
    .selected {
      background-color: #ffeeba !important;
      border: 2px solid #f0ad4e;
    }
  </style>
</head>
<body>
  <h2>Staff Roster Management System</h2>
  
  <!-- Date, Day, Staff Count -->
  <div class="date-container">
    <div>
      <label for="rosterDate">Roster Date:</label>
      <input type="date" id="rosterDate">
    </div>
    <div>
      <label for="rosterDay">Day:</label>
      <select id="rosterDay">
        <option value="Monday">Monday</option>
        <option value="Tuesday">Tuesday</option>
        <option value="Wednesday">Wednesday</option>
        <option value="Thursday">Thursday</option>
        <option value="Friday">Friday</option>
        <option value="Saturday">Saturday</option>
        <option value="Sunday">Sunday</option>
      </select>
    </div>
    <div>
      <label>Working Staff:</label>
      <span id="staffCount">0</span>
    </div>
  </div>
  
  <!-- Gap Policy: Slider now defaulting to 0 -->
  <div class="gap-policy-container">
    <div>
      <label for="gapThreshold">Gap Threshold (minutes): </label>
      <input type="range" id="gapThreshold" min="0" max="120" step="15" value="0">
      <span id="gapThresholdValue">0</span>
    </div>
  </div>
  
  <!-- Staff Table -->
  <table id="staffTable">
    <thead>
      <tr>
        <th>Staff ID</th>
        <th>Name</th>
        <th>Break Time</th>
        <th>HHMD Eligible</th>
        <th>Attendance</th>
        <th>Lock</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  
  <!-- Action Buttons -->
  <div class="button-container">
    <div class="button-row">
      <button class="roster-btn" id="addStaffBtn">Add Staff</button>
      <button class="roster-btn" id="importDataBtn">Import Data</button>
      <button class="roster-btn" id="exportDataBtn">Export Data</button>
    </div>
    <div class="button-row">
      <button class="roster-btn" id="shuffleBreaksBtn">Shuffle Breaks</button>
      <button class="roster-btn" id="generateRosterBtn">Generate Roster</button>
      <button class="roster-btn" id="copyTSVBtn">Copy Roster</button>
    </div>
    <div class="button-row">
      <button class="roster-btn" id="downloadCSVBtn">CSV</button>
      <button class="roster-btn" id="downloadPDFBtn">PDF</button>
      <button class="roster-btn" id="toggleBreakNoteBtn">Toggle Break Note</button>
    </div>
  </div>
  
  <!-- Generated Roster Display -->
  <h3>Generated Roster</h3>
  <div id="rosterContainer"></div>
  <!-- Manual Conflict Review Button -->
  <button class="roster-btn" id="reviewConflictsBtn">Review Selected Conflicts</button>
  
  <!-- Roster Health Summary -->
  <h4>Roster Health</h4>
  <div id="notesContainer"></div>
  
  <!-- Floating Break Time Note (draggable) -->
  <div id="breakListContainer">
    <strong>Staff Break Times</strong><br><br>
  </div>
  
  <!-- Hidden file input for importData() -->
  <input type="file" id="importFile" accept=".json" />
  
  <script>
    /************************************************************
     * Revised Roster System with Manual Conflict Review:
     *
     * - The gap threshold slider is now set to start at 0.
     * - A "Review Selected Conflicts" button is added below the roster display.
     *   Users can click cells to select problematic assignments (cells get highlighted)
     *   and then click the review button to have the system attempt to correct them.
     *
     * Additionally, the script enforces these strict slot rules:
     * - 20:30 and 01:30 are reserved for Vertical Patrol only.
     * - 07:30 is reserved for Tango Papa only.
     * - Lobby requires 2 staff per slot (displayed as "ID / ID").
     *
     * Preliminary rules are enforced:
     * 1. For non-Lobby locations, a staff member cannot be re-assigned in the same location within 2 hours.
     * 2. A staff member cannot be assigned in multiple locations during the same hour.
     * 3. No assignment is allowed while the staff is on break.
     ************************************************************/
  
    const STORAGE_KEY = 'staffListData';
    const ROSTER_TIMES = [
      "20:00", "20:30", "21:00", "22:00", "23:00",
      "00:00", "01:00", "01:30", "02:00", "03:00",
      "04:00", "05:00", "06:00", "07:00", "07:30"
    ];
    const BREAK_TIME_POOL = [
      "20:00-21:30", "21:30-23:30", "22:00-00:00",
      "23:00-01:00", "00:00-02:00", "01:30-03:30",
      "02:00-04:00", "03:00-05:00", "04:00-06:00",
      "05:00-07:00", "06:00-08:00"
    ];
// For a two-phase approach, define which slots are “critical” vs. “secondary”.
const criticalPhaseSlots = [
  "20:00", "20:30", "21:00", "22:00", "23:00",
  "00:00", "01:00", "01:30", "02:00"
];

const secondaryPhaseSlots = [
  "03:00", "04:00", "05:00", "06:00", "07:00", "07:30"
];
  
      
    // (Optional) Priority and critical rules remain as before.
    // For this revision, we retain the assignment rules regarding special slots.
  
    const rosterSystem = {
      init: function() {
        try {
          const requiredElements = [
            'rosterDate', 'rosterDay', 'gapThreshold', 'staffCount', 'staffTable',
            'addStaffBtn', 'importDataBtn', 'exportDataBtn', 'shuffleBreaksBtn',
            'generateRosterBtn', 'copyTSVBtn', 'downloadCSVBtn', 'downloadPDFBtn',
            'toggleBreakNoteBtn', 'importFile', 'rosterContainer', 'notesContainer',
            'breakListContainer', 'reviewConflictsBtn'
          ];
          let missingElements = [];
          requiredElements.forEach(id => {
            if (!document.getElementById(id)) missingElements.push(id);
          });
          if (missingElements.length > 0) {
            console.error("Missing HTML elements:", missingElements);
            return;
          }
          if (typeof jsPDF === "undefined") {
            console.error("jsPDF library failed to load.");
          }
  
          const today = new Date().toISOString().split('T')[0];
          document.getElementById('rosterDate').value = today;
          const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
          document.getElementById('rosterDay').value = days[new Date().getDay()];
  
          // Slider now defaults to 0.
          const gapSlider = document.getElementById("gapThreshold");
          const gapDisplay = document.getElementById("gapThresholdValue");
          gapSlider.addEventListener("input", function() { gapDisplay.innerText = this.value; });
          gapSlider.addEventListener("change", () => this.generateRoster());
  
          document.getElementById('addStaffBtn').addEventListener('click', () => this.addStaff());
          document.getElementById('importDataBtn').addEventListener('click', () => this.importData());
          document.getElementById('exportDataBtn').addEventListener('click', () => this.exportData());
          document.getElementById('shuffleBreaksBtn').addEventListener('click', () => this.shuffleBreakTimes());
          document.getElementById('generateRosterBtn').addEventListener('click', () => this.generateRoster());
          document.getElementById('copyTSVBtn').addEventListener('click', () => this.copyTSV());
          document.getElementById('downloadCSVBtn').addEventListener('click', () => this.downloadRoster('csv'));
          document.getElementById('downloadPDFBtn').addEventListener('click', () => this.downloadRoster('pdf'));
          document.getElementById('toggleBreakNoteBtn').addEventListener('click', this.toggleBreakNote);
          document.getElementById('reviewConflictsBtn').addEventListener('click', () => this.reviewSelectedConflicts());
  
          this.makeDraggable(document.getElementById('breakListContainer'));
          this.loadStaffList();
        } catch (e) {
          console.error("Initialization error:", e);
        }
      },
  
      loadStaffList: function() {
        const stored = localStorage.getItem(STORAGE_KEY);
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        if (stored) {
          const staffList = JSON.parse(stored);
          tbody.innerHTML = "";
          staffList.forEach(staff => { tbody.innerHTML += this.getStaffRowHTML(staff); });
        } else {
          this.addStaff();
        }
        this.addListenersToAllRows();
        this.updateStaffCount();
      },
  
      saveStaffList: function() {
        const staffList = this.getCurrentStaffList();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(staffList));
      },
  
      getCurrentStaffList: function() {
        const rows = document.getElementById("staffTable").querySelector("tbody").rows;
        const staffList = [];
        for (let row of rows) {
          const timeInputs = row.cells[2].querySelectorAll("input[type='time']");
          const startInput = timeInputs[0].value.padEnd(5, ":00");
          const endInput = timeInputs[1].value.padEnd(5, ":00");
          const breakTime = `${startInput}-${endInput}`.replace(/:+/g, ":");
          const staffData = {
            staffID: row.cells[0].querySelector("input").value.trim(),
            name: row.cells[1].querySelector("input").value.trim(),
            breakTime: breakTime,
            hhmdEligible: row.cells[3].querySelector("select").value,
            attendance: row.cells[4].querySelector("select").value,
            locked: row.cells[5].querySelector("input[type='checkbox']").checked,
            assigned: row.dataset.assigned ? JSON.parse(row.dataset.assigned) : []
          };
          staffList.push(staffData);
        }
        return staffList;
      },
  
      getStaffRowHTML: function(staff = {}) {
        let [startVal, endVal] = ["21:30", "23:30"];
        if (staff.breakTime && staff.breakTime.includes("-")) {
          [startVal, endVal] = staff.breakTime.split("-");
        }
        return `
          <tr data-assigned='${JSON.stringify(staff.assigned || [])}'>
            <td><input type="text" value="${staff.staffID || ''}" class="staff-input"></td>
            <td><input type="text" value="${staff.name || ''}" class="staff-input"></td>
            <td>
              <div class="break-time-container">
                <input type="time" value="${startVal}" step="1800" class="time-input">
                <span>-</span>
                <input type="time" value="${endVal}" step="1800" class="time-input">
              </div>
            </td>
            <td>
              <select class="staff-select">
                <option value="Yes" ${staff.hhmdEligible==="Yes"?"selected":""}>Yes</option>
                <option value="No" ${staff.hhmdEligible==="No"?"selected":""}>No</option>
              </select>
            </td>
            <td>
              <select class="staff-select">
                <option value="Yes" ${staff.attendance==="Yes"?"selected":""}>Yes</option>
                <option value="No" ${staff.attendance==="No"?"selected":""}>No</option>
              </select>
            </td>
            <td>
              <input type="checkbox" ${staff.locked ? "checked" : ""}>
            </td>
            <td><button class="remove-btn" data-staff-id="${staff.staffID || ''}">Remove</button></td>
          </tr>
        `;
      },
  
      addStaff: function() {
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        const newStaff = {
          staffID: "",
          name: "",
          breakTime: "21:30-23:30",
          hhmdEligible: "No",
          attendance: "Yes",
          locked: false,
          assigned: []
        };
        tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML(newStaff));
        this.addListenersToAllRows();
        this.saveStaffList();
        this.updateStaffCount();
      },
  
      removeRow: function(button) {
        button.closest("tr").remove();
        this.saveStaffList();
        this.updateStaffCount();
      },
  
      addListenersToAllRows: function() {
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        const self = this;
        const inputs = tbody.querySelectorAll("input, select");
        inputs.forEach(inp => {
          inp.addEventListener("change", () => {
            self.saveStaffList();
            self.updateStaffCount();
          });
        });
        const removeButtons = tbody.querySelectorAll(".remove-btn");
        removeButtons.forEach(btn => {
          btn.removeEventListener("click", btn._clickHandler);
          btn._clickHandler = function() { self.removeRow(this); };
          btn.addEventListener("click", btn._clickHandler);
        });
      },
  
      updateStaffCount: function() {
        const staffList = this.getCurrentStaffList();
        const workingCount = staffList.filter(st => st.attendance === "Yes").length;
        document.getElementById("staffCount").textContent = workingCount;
      },
  
      shuffleBreakTimes: function() {
        const staffList = this.getCurrentStaffList();
        staffList.forEach(st => {
          if (st.attendance === "Yes" && !st.locked) {
            const randomIndex = Math.floor(Math.random() * BREAK_TIME_POOL.length);
            st.breakTime = BREAK_TIME_POOL[randomIndex];
          }
        });
        this.applyStaffListToTable(staffList);
        this.saveStaffList();
        this.displayBreakList();
        alert("Break times shuffled!");
      },
  
      applyStaffListToTable: function(staffList) {
        const tbody = document.getElementById("staffTable").querySelector("tbody");
        tbody.innerHTML = "";
        staffList.forEach(staff => {
          tbody.innerHTML += this.getStaffRowHTML(staff);
        });
        this.addListenersToAllRows();
        this.updateStaffCount();
      },
  
      // Preliminary Rule 1: For non-Lobby locations, do not assign a staff if they already have an assignment in that location within 2 hours.
      canAssignStaffAtLocationAndTime: function(staff, loc, slot) {
        if (loc !== "Lobby") {
          for (let assign of staff.assigned) {
            if (assign.location === loc) {
              const diff = Math.abs(this.timeToMinutes(slot) - this.timeToMinutes(assign.slot));
              if (diff < 120) return false;
            }
          }
        }
        return true;
      },
  
      // Preliminary Rule 2: A staff cannot be assigned in multiple locations during the same hour.
      isDoubleBooked: function(staff, slot) {
        const newHour = slot.split(":")[0];
        return staff.assigned.some(a => a.slot.split(":")[0] === newHour);
      },
  
      // Preliminary Rule 3: No assignment while the staff is on break.
      isOnBreak: function(staff, slot) {
        if (!staff.breakTime) return false;
        const [bStart, bEnd] = staff.breakTime.split("-");
        return (slot >= bStart && slot < bEnd);
      },
  
      timeToMinutes: function(timeStr) {
        if (!timeStr || typeof timeStr !== "string" || !timeStr.match(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)) return 0;
        const [hours, minutes] = timeStr.split(":").map(Number);
        const adjustedHours = hours < 8 ? hours + 24 : hours;
        return (adjustedHours - 20) * 60 + minutes;
      },
  
      // Phase-based generation:
      // We split into two phases (critical and secondary) then merge into one unified roster.
      generateRoster: function() {
        const dayValue = document.getElementById("rosterDay").value;
        let staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        if (!staffList.length) {
          alert("Please add staff members before generating roster.");
          return;
        }
        staffList.forEach(st => { st.assigned = []; });
        let newRoster = {};
  
        // Phase 1: Critical hours (20:00–02:00)
        this.generateForSlots(criticalPhaseSlots, staffList, newRoster);
        // Phase 2: Secondary hours (03:00–07:30)
        this.generateForSlots(secondaryPhaseSlots, staffList, newRoster);
  
        // Massive shortfall: if <6 staff, force an HHMD-eligible staff at Lobby 20:00.
        if (staffList.length < 6) {
          if (newRoster["Lobby"] && newRoster["Lobby"]["20:00"] === "") {
            let hhmdStaff = staffList.find(s => s.hhmdEligible === "Yes");
            if (hhmdStaff) {
              newRoster["Lobby"]["20:00"] = hhmdStaff.staffID + " / " + hhmdStaff.staffID;
              hhmdStaff.assigned.push({ slot: "20:00", location: "Lobby" });
            }
          }
        }
  
        window.generatedRosterData = newRoster;
        this.displayRoster(newRoster, {}, new Date());
        alert("Roster generated successfully.");
      },
  
      // This helper assigns staff for the given slots based on priority.
      generateForSlots: function(slots, staffList, roster) {
        let priorityLocations = ["HHMD", "Guard House", "Lobby", "Vertical Patrol", "Tango Papa", "Pass Counter"];
        const dayValue = document.getElementById("rosterDay").value;
        if (dayValue !== "Saturday" && dayValue !== "Sunday") {
          priorityLocations.splice(3, 0, "Report Room");
        }
  
        priorityLocations.forEach(loc => {
          if (!roster[loc]) roster[loc] = {};
          slots.forEach(slot => {
            // Enforce special slot rules:
            // For Vertical Patrol: Only assign at 20:30 and 01:30.
            if ((slot === "20:30" || slot === "01:30") && loc !== "Vertical Patrol") {
              roster[loc][slot] = "";
              return;
            }
            // For Tango Papa: Only assign at 07:30.
            if (slot === "07:30" && loc !== "Tango Papa") {
              roster[loc][slot] = "";
              return;
            }
  
            if (loc === "Vertical Patrol") {
              let assigned = "";
              for (let member of staffList) {
                if (!this.isOnBreak(member, slot) &&
                    !this.isDoubleBooked(member, slot) &&
                    this.canAssignStaffAtLocationAndTime(member, loc, slot)) {
                  assigned = member.staffID;
                  member.assigned.push({ slot, location: loc });
                  break;
                }
              }
              // Force emergency assignment at 20:30 if necessary.
              if (slot === "20:30" && !assigned) {
                let emergency = this.findEmergencyStaff(staffList, slot);
                if (emergency) { assigned = emergency.staffID; emergency.assigned.push({ slot, location: loc }); }
              }
              roster[loc][slot] = assigned;
              return;
            }
            if (loc === "Tango Papa") {
              let assigned = "";
              for (let member of staffList) {
                if (!this.isOnBreak(member, slot) &&
                    !this.isDoubleBooked(member, slot) &&
                    this.canAssignStaffAtLocationAndTime(member, loc, slot)) {
                  assigned = member.staffID;
                  member.assigned.push({ slot, location: loc });
                  break;
                }
              }
              roster[loc][slot] = assigned;
              return;
            }
            if (loc === "Lobby") {
              let candidate1 = "";
              let candidate2 = "";
              for (let member of staffList) {
                if (!this.isOnBreak(member, slot) &&
                    !this.isDoubleBooked(member, slot) &&
                    this.canAssignStaffAtLocationAndTime(member, loc, slot)) {
                  candidate1 = member.staffID;
                  member.assigned.push({ slot, location: loc });
                  break;
                }
              }
              for (let member of staffList) {
                if (member.staffID === candidate1) continue;
                if (!this.isOnBreak(member, slot) &&
                    !this.isDoubleBooked(member, slot) &&
                    this.canAssignStaffAtLocationAndTime(member, loc, slot)) {
                  candidate2 = member.staffID;
                  member.assigned.push({ slot, location: loc });
                  break;
                }
              }
              let assigned = candidate1 && candidate2 ? candidate1 + " / " + candidate2 : candidate1;
              roster[loc][slot] = assigned;
              return;
            }
  
            // For all other locations, normal assignment.
            let assigned = "";
            for (let member of staffList) {
              if (!this.isOnBreak(member, slot) &&
                  !this.isDoubleBooked(member, slot) &&
                  this.canAssignStaffAtLocationAndTime(member, loc, slot)) {
                assigned = member.staffID;
                member.assigned.push({ slot, location: loc });
                break;
              }
            }
            roster[loc][slot] = assigned;
          });
        });
      },
  
      displayRoster: function(roster, conflicts = {}, creationTime) {
        const container = document.getElementById("rosterContainer");
        const rosterDate = document.getElementById("rosterDate").value;
        let headerHTML = `<div style="text-align:left; margin-bottom:10px; font-size:12px;">
          Roster Date: ${rosterDate} | Generated on: ${creationTime.toLocaleString()}
        </div>`;
        let tableHTML = `<table id="editableRoster"><thead><tr><th>Location</th>`;
        ROSTER_TIMES.forEach(slot => { tableHTML += `<th>${slot}</th>`; });
        tableHTML += `</tr></thead><tbody>`;
        Object.keys(roster).forEach(loc => {
          tableHTML += `<tr data-loc="${loc}"><td>${loc}</td>`;
          ROSTER_TIMES.forEach(slot => {
            tableHTML += `<td contenteditable="true" data-slot="${slot}" style="min-width:80px;">
                          ${roster[loc][slot] || ""}
                          </td>`;
          });
          tableHTML += `</tr>`;
        });
        tableHTML += `</tbody></table>`;
        container.innerHTML = headerHTML + tableHTML;
  
        container.insertAdjacentHTML("beforeend", `<button class="roster-btn" id="saveEditsBtn">Save Edits</button>`);
        document.getElementById("saveEditsBtn").addEventListener("click", () => this.saveEditedRoster());
  
        document.querySelectorAll("#editableRoster td[contenteditable]").forEach(cell => {
          cell.addEventListener("click", function() { this.classList.toggle("selected"); });
        });
      },
  
      displayBreakList: function() {
        const container = document.getElementById("breakListContainer");
        const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        let html = "<strong>Staff Break Times</strong><br><br>";
        staffList.forEach(st => { html += `${st.staffID || "??"} (${st.name || "??"}): ${st.breakTime}<br>`; });
        container.innerHTML = html;
      },
  
      getEditableRosterData: function() {
        const rosterTable = document.getElementById("editableRoster");
        if (!rosterTable) return [];
        const rows = rosterTable.querySelectorAll("tr");
        let data = [];
        rows.forEach(row => {
          let rowData = [];
          row.querySelectorAll("th, td").forEach(cell => { rowData.push(cell.innerText.trim()); });
          data.push(rowData);
        });
        return data;
      },
  
      getStaffBreakData: function() {
        const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
        let data = [["Staff ID", "Name", "Break Time"]];
        staffList.forEach(st => { data.push([st.staffID, st.name, st.breakTime]); });
        return data;
      },
  
      downloadRoster: function(format) {
        const rosterData = this.getEditableRosterData();
        if (!rosterData.length) {
          alert("No roster data found. Please generate the roster first.");
          return;
        }
        const breakData = this.getStaffBreakData();
        if (format === "csv") {
          this.downloadAsCSV(rosterData, breakData);
        } else if (format === "pdf") {
          this.downloadAsPDF(rosterData, breakData);
        }
      },
  
      downloadAsCSV: function(rosterData, breakData) {
        const convertToCSV = (arr) => arr.map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const rosterCSV = convertToCSV(rosterData);
        const breakCSV = convertToCSV(breakData);
        const finalCSV = rosterCSV + "\n\nStaff Break Times:\n" + breakCSV;
        const blob = new Blob([finalCSV], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", "Roster_with_Breaks.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      },
  
      downloadAsPDF: function(rosterData, breakData) {
        const formattedBreakData = breakData.map(row => {
          if (row[2]) { row[2] = row[2].replace(/(\d{2}:\d{2})-(\d{2}:\d{2})/, "$1 to $2"); }
          return row;
        });
        const { jsPDF } = window.jspdf;
        if (!jsPDF) {
          alert("jsPDF library not found. PDF export not available.");
          return;
        }
        const doc = new jsPDF('landscape', 'pt', 'a4');
        const rosterDate = document.getElementById("rosterDate").value;
        const creationTime = new Date().toLocaleString();
        doc.setFontSize(10);
        doc.text(`Roster Date: ${rosterDate} | Generated on: ${creationTime}`, 40, 20);
        doc.text("Roster", 40, 40);
        doc.autoTable({
          startY: 50,
          head: [rosterData[0]],
          body: rosterData.slice(1),
          margin: { left: 40 },
          theme: 'grid',
          styles: { fontSize: 8 },
          headStyles: { fillColor: [41, 128, 185] }
        });
        let finalY = doc.lastAutoTable.finalY + 20;
        doc.text("Staff Break Times", 40, finalY);
        doc.autoTable({
          startY: finalY + 10,
          head: [formattedBreakData[0]],
          body: formattedBreakData.slice(1),
          margin: { left: 40 },
          theme: 'striped',
          styles: { fontSize: 8, cellPadding: 4 },
          columnStyles: {
            0: { cellWidth: 80 },
            1: { cellWidth: 100 },
            2: { cellWidth: 80 }
          },
          headStyles: { fillColor: [52, 152, 219] }
        });
        doc.save("Roster_with_Breaks.pdf");
      },
  
      importData: function() {
        const fileInput = document.getElementById('importFile');
        fileInput.value = "";
        fileInput.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const importedStaff = JSON.parse(text);
            if (!Array.isArray(importedStaff)) {
              alert("Invalid JSON structure. Must be an array of staff objects.");
              return;
            }
            importedStaff.forEach(staff => {
              if (!staff.breakTime || !staff.breakTime.match(/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/)) {
                throw new Error(`Invalid break time format for staff ${staff.staffID}: ${staff.breakTime}`);
              }
            });
            localStorage.setItem(STORAGE_KEY, JSON.stringify(importedStaff));
            this.loadStaffList();
            alert("Staff data imported successfully.");
          } catch (err) {
            alert("Error reading or parsing file: " + err);
          }
        };
        fileInput.click();
      },
  
      exportData: function() {
        const staffList = this.getCurrentStaffList();
        const jsonStr = JSON.stringify(staffList, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "staff_data.json";
        link.click();
        URL.revokeObjectURL(url);
      },
  
      copyTSV: function() {
        const rosterTable = document.getElementById("editableRoster");
        if (!rosterTable) {
          alert("No generated roster table found to copy.");
          return;
        }
        let tsv = "";
        const rows = rosterTable.querySelectorAll("tr");
        rows.forEach(row => {
          const cells = row.querySelectorAll("th, td");
          let rowData = [];
          cells.forEach(cell => { rowData.push(cell.textContent.trim()); });
          tsv += rowData.join("\t") + "\n";
        });
        navigator.clipboard.writeText(tsv).then(() => { alert("Roster copied as TSV!"); })
          .catch(err => { console.error("Clipboard error:", err); alert("Unable to copy to clipboard."); });
      },
  
      saveEditedRoster: function() {
        alert("Save edits functionality is not fully implemented. (Placeholder)");
      },
  
      toggleBreakNote: function() {
        const note = document.getElementById("breakListContainer");
        note.style.display = note.style.display === "none" ? "block" : "none";
      },
  
      makeDraggable: function(el) {
        let pos = { top: 0, left: 0, x: 0, y: 0 };
        const mouseDownHandler = (e) => {
          pos = { left: el.offsetLeft, top: el.offsetTop, x: e.clientX, y: e.clientY };
          document.addEventListener('mousemove', mouseMoveHandler);
          document.addEventListener('mouseup', mouseUpHandler);
        };
        const mouseMoveHandler = (e) => {
          const dx = e.clientX - pos.x;
          const dy = e.clientY - pos.y;
          el.style.left = pos.left + dx + 'px';
          el.style.top = pos.top + dy + 'px';
        };
        const mouseUpHandler = () => {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
        };
        el.addEventListener('mousedown', mouseDownHandler);
      },
  
      // Manual Review of Problematic Assignments:
      reviewSelectedConflicts: function() {
        const selectedCells = document.querySelectorAll("#editableRoster td.selected");
        if (!selectedCells.length) {
          alert("No cells selected for conflict review.");
          return;
        }
        const roster = window.generatedRosterData;
        const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
  
        selectedCells.forEach(cell => {
          const slot = cell.getAttribute("data-slot");
          const loc = cell.parentElement.getAttribute("data-loc");
          let cellAssignments = cell.textContent.split(",").map(s => s.trim()).filter(Boolean);
  
          cellAssignments.forEach(staffID => {
            const staff = staffList.find(s => s.staffID === staffID);
            if (!staff) return;
            let conflictFound = false;
            if (this.isOnBreak(staff, slot)) {
              conflictFound = true;
            } else {
              const newHour = slot.split(":")[0];
              if (staff.assigned.some(a => a.slot.split(":")[0] === newHour && a.location !== loc)) {
                conflictFound = true;
              }
              if (loc !== "Lobby") {
                for (let assign of staff.assigned) {
                  if (assign.location === loc) {
                    const diff = Math.abs(this.timeToMinutes(slot) - this.timeToMinutes(assign.slot));
                    if (diff < 120) {
                      conflictFound = true;
                      break;
                    }
                  }
                }
              }
            }
            if (conflictFound) {
              console.log(`Conflict for staff ${staffID} at ${loc} during ${slot}`);
              this.removeAssignment(roster, staff, slot, loc);
              cellAssignments = cellAssignments.filter(id => id !== staffID);
              const replacement = this.findAvailableStaff(staffList, slot, loc) || this.findEmergencyStaff(staffList, slot);
              if (replacement && !this.wouldCauseConflict(roster, replacement, slot, loc)) {
                cellAssignments.push(replacement.staffID);
                replacement.assigned.push({ slot, location: loc });
                console.log(`Replaced ${staffID} with ${replacement.staffID} at ${loc} during ${slot}`);
              } else {
                console.log(`No replacement found for ${staffID} at ${loc} during ${slot}`);
              }
            }
          });
  
          if (cellAssignments.length === 1) {
            const extraStaff = this.findAvailableStaff(staffList, slot, loc);
            if (extraStaff && !this.isDoubleBooked(extraStaff, slot) && !this.isOnBreak(extraStaff, slot)) {
              cellAssignments.push(extraStaff.staffID);
              extraStaff.assigned.push({ slot, location: loc });
              console.log(`Added extra staff ${extraStaff.staffID} at ${loc} during ${slot}`);
            }
          }
  
          roster[loc][slot] = cellAssignments.join(", ");
          cell.textContent = roster[loc][slot];
          cell.classList.remove("selected");
        });
  
        this.displayRoster(roster, {}, new Date());
        alert("Selected conflicts reviewed and updated where possible.");
      },
  
      wouldCauseConflict: function(roster, staff, slot, loc) {
        if (this.isOnBreak(staff, slot) || this.isDoubleBooked(staff, slot)) return true;
        const assignments = staff.assigned.concat({ slot, location: loc });
        assignments.sort((a, b) => this.timeToMinutes(a.slot) - this.timeToMinutes(b.slot));
        const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
        for (let i = 0; i < assignments.length - 1; i++) {
          const currTime = this.timeToMinutes(assignments[i].slot);
          const nextTime = this.timeToMinutes(assignments[i + 1].slot);
          if (assignments[i].location === loc || assignments[i + 1].location === loc) {
            if (Math.abs(nextTime - currTime) < gapThreshold) return true;
          }
        }
        return false;
      }
    };
  
    window.RosterApp = rosterSystem;
    console.log("Starting script execution (Revised with Manual Conflict Review and Slider=0)...");
    rosterSystem.init();
  </script>
</body>
</html>