<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Staff Roster System v5.9M - Manual Editing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, getDocs, doc, setDoc, addDoc, deleteDoc, onSnapshot, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // IMPORTANT: Replace with your actual Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAP7b4KcwRYPMZjNc2TWsNqMvC3ywImhOM",
            authDomain: "roster-4a997.firebaseapp.com",
            projectId: "roster-4a997",
            storageBucket: "roster-4a997.appspot.com",
            messagingSenderId: "901381868881",
            appId: "1:901381868881:web:92930481d6c1c85fedd770"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Make db and firebase utilities globally available for the main script
        window.db = db;
        window.firebase = {
             collection, getDocs, doc, setDoc, addDoc, deleteDoc, onSnapshot, query
        };
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
        .btn:hover { transform: translateY(-1px); }
        .modal { display: none; position: fixed; z-index: 50; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 1000px; border-radius: 0.5rem; }
        #editableRoster th, #editableRoster td, #staffTable th, #staffTable td { white-space: nowrap; }
        #staffTable td:nth-child(2), #staffTable th:nth-child(2) { white-space: normal; }
        #editableRoster thead th:first-child, #editableRoster tbody td:first-child,
        #staffTable thead th:first-child, #staffTable tbody td:first-child { position: sticky; left: 0; z-index: 10; background-color: white; }
        #editableRoster thead th:first-child, #staffTable thead th:first-child { z-index: 20; background-color: #f3f4f6; }
        .not-applicable { background-color: #e5e7eb; }
        .location-cell-multiline { line-height: 1.2; padding-top: 4px; padding-bottom: 4px; }
        .roster-cell select { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-color: transparent; border: none; width: 100%; text-align: center; font-size: 0.875rem; }
        .roster-cell select:focus { outline: 1px solid #4f46e5; border-radius: 3px; }
        .empty-assignable-cell { background-color: #f3f4f6; }
        .conflict-cell { background-color: #fee2e2 !important; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-indigo-600">Staff Roster System v5.9M</h1>
            <p class="text-lg text-gray-500 mt-2">Manual Editing & Live Validation</p>
        </header>

        <!-- UI sections -->
        <div class="card p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 items-center">
                <div><label for="rosterDate" class="font-semibold text-gray-700">Roster Date:</label><input type="date" id="rosterDate" class="mt-1 w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></div>
                <div><label for="rosterDay" class="font-semibold text-gray-700">Day:</label><select id="rosterDay" class="mt-1 w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"><option>Monday</option><option>Tuesday</option><option>Wednesday</option><option>Thursday</option><option>Friday</option><option>Saturday</option><option>Sunday</option></select></div>
                <div class="text-center md:text-right"><span class="text-lg font-semibold">Working Staff:</span><span id="staffCount" class="text-2xl font-bold text-indigo-600 ml-2">0</span></div>
            </div>
        </div>
        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Staff Management (Live from Cloud)</h2>
            <div class="overflow-x-auto">
                <table id="staffTable" class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-100"><tr><th class="sticky left-0 px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Staff ID</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Break Time</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">HHMD Eligible</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Attendance</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Lock</th><th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th></tr></thead><tbody class="bg-white divide-y divide-gray-200"></tbody></table>
            </div>
            <div class="mt-6 flex flex-wrap gap-4 justify-center"><button id="addStaffBtn" class="btn bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-indigo-700">Add Staff</button><button id="shuffleBreaksBtn" class="btn bg-purple-600 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-purple-700">Shuffle Breaks</button></div>
        </div>
        <div class="card p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Roster Controls</h2>
            <div class="flex justify-center"><button id="generateRosterBtn" class="btn bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-green-700 text-lg">Generate Roster</button></div>
            <div id="notification-container" class="mt-4 space-y-2"></div>
            <div id="rosterContainer" class="mt-2 overflow-x-auto"></div>
        </div>
    </div>
    <div id="pdfModal" class="modal"><div class="modal-content"><div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold">PDF Preview</h3><div><a id="pdfDownloadLink" href="#" download="roster.pdf" class="btn bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-blue-700 mr-4">Download Now</a><button id="closePdfBtn" class="text-gray-500 hover:text-gray-800 text-3xl font-bold">&times;</button></div></div><iframe id="pdfPreview" class="w-full h-[75vh]"></iframe></div></div>

<script type="module">
const rosterSystem = {
    // --- CONFIG & STATE ---
    ROSTER_TIMES: ["20:00", "20:30", "21:00", "22:00", "23:00", "00:00", "01:00", "01:30", "02:00", "03:00", "04:00", "05:00", "06:00", "06:30", "07:00"],
    LOCATIONS: [ { name: "Pass Counter", needed: 2, isMultiStaff: true }, { name: "HHMD", needed: 1 }, { name: "Lobby", needed: 2, isMultiStaff: true }, { name: "Guard House", needed: 1 }, { name: "Vertical Patrol", needed: 1 }, { name: "Report Room", needed: 1 }, { name: "Tango Papa", needed: 1 } ],
    OUTPUT_ORDER: ["Pass Counter", "HHMD", "Guard House", "Lobby", "Report Room", "Vertical Patrol", "Tango Papa"],
    CRITICAL_DUTIES: { "Vertical Patrol": ["20:30", "23:00", "01:30", "04:00", "06:30"], "Report Room": ["20:00", "21:00"], "Tango Papa": ["07:00"] },
    
    generatedRoster: null, 
    staffDataCache: [], 
    db: null, 
    firebase: null,

    // --- INITIALIZATION ---
    async init() {
        // Wait until the firebase objects are available on the window
        await new Promise(resolve => { 
            const interval = setInterval(() => { 
                if (window.db && window.firebase) { 
                    clearInterval(interval); 
                    this.db = window.db; 
                    this.firebase = window.firebase; 
                    console.log("Roster System v5.9M Initialized"); 
                    resolve(); 
                } 
            }, 50); 
        });
        this.setupEventListeners(); 
        this.initializeDate(); 
        this.listenForStaffUpdates();
    },

    initializeDate() { 
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        document.getElementById("rosterDate").value = `${yyyy}-${mm}-${dd}`;
        const days = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
        document.getElementById("rosterDay").value = days[today.getDay()];
    },

    setupEventListeners() { 
        document.getElementById("addStaffBtn").addEventListener("click",()=>this.addStaffToFirestore());
        document.getElementById("generateRosterBtn").addEventListener("click",()=>this.runRosterGeneration());
        document.getElementById("shuffleBreaksBtn").addEventListener("click",()=>this.shuffleBreaks());
        document.getElementById("closePdfBtn").addEventListener("click",()=>this.closePdfModal());
    },
    
    // --- FIREBASE DATA MANAGEMENT ---
    listenForStaffUpdates() {
        const { collection, query, onSnapshot } = this.firebase;
        const staffCollection = query(collection(this.db, "staff"));
        onSnapshot(staffCollection, (querySnapshot) => {
            const staffList = [];
            querySnapshot.forEach(doc => {
                staffList.push({ docId: doc.id, ...doc.data() });
            });
            this.staffDataCache = staffList.sort((a, b) => (a.id || "").localeCompare(b.id || ""));
            this.renderStaffTable(this.staffDataCache);
            this.updateStaffCount();
        });
    },

    renderStaffTable(staffList) {
        const tableBody = document.getElementById("staffTable").querySelector("tbody");
        tableBody.innerHTML = "";
        staffList.forEach(staff => {
            const row = tableBody.insertRow();
            row.dataset.docId = staff.docId;
            row.innerHTML = `
                <td class="sticky left-0 bg-white px-6 py-4"><input data-field="id" class="w-24 p-1 border rounded" type="text" value="${staff.id || ""}"></td>
                <td class="px-6 py-4"><input data-field="name" class="w-36 p-1 border rounded" type="text" value="${staff.name || ""}"></td>
                <td class="px-6 py-4">
                    <div class="flex items-center gap-1">
                        <input type="time" data-field="breakStart" value="${staff.breakStart || "22:00"}" step="1800" class="p-1 border rounded">
                        <span>-</span>
                        <input type="time" data-field="breakEnd" value="${staff.breakEnd || "00:00"}" step="1800" class="p-1 border rounded">
                    </div>
                </td>
                <td class="px-6 py-4"><select data-field="hhmd" class="p-1 border rounded"><option value="Yes" ${"Yes" === staff.hhmd ? "selected" : ""}>Yes</option><option value="No" ${"Yes" !== staff.hhmd ? "selected" : ""}>No</option></select></td>
                <td class="px-6 py-4"><select data-field="attendance" class="p-1 border rounded"><option value="Yes" ${"No" !== staff.attendance ? "selected" : ""}>Yes</option><option value="No" ${"No" === staff.attendance ? "selected" : ""}>No</option></select></td>
                <td class="px-6 py-4"><input type="checkbox" data-field="locked" ${staff.locked ? "checked" : ""} class="h-5 w-5 rounded text-indigo-600 focus:ring-indigo-500"></td>
                <td class="px-6 py-4"><button class="remove-btn text-red-600 hover:text-red-800 font-semibold">Remove</button></td>
            `;
            row.querySelectorAll("input, select").forEach(input => input.addEventListener("change", (e) => this.updateStaffInFirestore(e)));
            row.querySelector(".remove-btn").addEventListener("click", (e) => this.deleteStaffFromFirestore(e));
        });
    },

    async addStaffToFirestore() {
        const { collection, addDoc } = this.firebase;
        try {
            await addDoc(collection(this.db, "staff"), {
                id: `S${Date.now().toString().slice(-4)}`,
                name: "New Staff",
                breakStart: "22:00",
                breakEnd: "00:00",
                hhmd: "No",
                attendance: "Yes",
                locked: false,
                createdAt: new Date()
            });
            this.showNotification("Added new staff member.", "success");
        } catch (error) {
            console.error("Error adding staff:", error);
            this.showNotification("Error adding staff member.", "error");
        }
    },

    async updateStaffInFirestore(event) {
        const { doc, setDoc } = this.firebase;
        const row = event.target.closest("tr");
        const docId = row.dataset.docId;
        const updatedData = {
            id: row.querySelector('[data-field="id"]').value,
            name: row.querySelector('[data-field="name"]').value,
            breakStart: row.querySelector('[data-field="breakStart"]').value,
            breakEnd: row.querySelector('[data-field="breakEnd"]').value,
            hhmd: row.querySelector('[data-field="hhmd"]').value,
            attendance: row.querySelector('[data-field="attendance"]').value,
            locked: row.querySelector('[data-field="locked"]').checked
        };
        try {
            await setDoc(doc(this.db, "staff", docId), updatedData, { merge: true });
        } catch (error) {
            console.error("Error updating staff:", error);
            this.showNotification("Error updating staff member.", "error");
        }
    },

    async deleteStaffFromFirestore(event) {
        const { doc, deleteDoc } = this.firebase;
        const row = event.target.closest("tr");
        const docId = row.dataset.docId;
        if (window.confirm(`Are you sure you want to remove staff member ${row.querySelector("[data-field=id]").value}?`)) {
            await deleteDoc(doc(this.db, "staff", docId));
        }
    },

    async saveRosterToFirestore(rosterData) {
        const { doc, setDoc } = this.firebase;
        const rosterDate = document.getElementById("rosterDate").value;
        if (rosterDate) {
            const dataToSave = {
                date: rosterDate,
                day: document.getElementById("rosterDay").value,
                roster: rosterData,
                createdAt: new Date()
            };
            try {
                await setDoc(doc(this.db, "rosters", rosterDate), dataToSave);
                this.showNotification(`Roster for ${rosterDate} saved to cloud successfully!`, "success");
            } catch (error) {
                console.error("Error saving roster:", error);
                this.showNotification("Could not save roster to the cloud.", "error");
            }
        } else {
            this.showNotification("Please select a valid date before saving.", "error");
        }
    },

    updateStaffCount() {
        const workingStaffCount = this.staffDataCache.filter(s => s.attendance === 'Yes').length;
        document.getElementById("staffCount").textContent = workingStaffCount;
    },

    async shuffleBreaks() {
        const presentUnlockedStaff = this.staffDataCache.filter(s => s.attendance === 'Yes' && !s.locked);
        if (presentUnlockedStaff.length < 2) {
            this.showNotification("Not enough unlocked, present staff to shuffle breaks.", "warning");
            return;
        }

        let breakTimes = presentUnlockedStaff.map(s => ({ start: s.breakStart, end: s.breakEnd }));
        // Fisher-Yates shuffle
        for (let i = breakTimes.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [breakTimes[i], breakTimes[j]] = [breakTimes[j], breakTimes[i]];
        }

        const { doc, setDoc } = this.firebase;
        const updatePromises = [];
        presentUnlockedStaff.forEach((staff, index) => {
            const newBreaks = { breakStart: breakTimes[index].start, breakEnd: breakTimes[index].end };
            const staffDocRef = doc(this.db, "staff", staff.docId);
            updatePromises.push(setDoc(staffDocRef, newBreaks, { merge: true }));
        });

        try {
            await Promise.all(updatePromises);
            this.showNotification("Break times have been shuffled in the cloud.", "success");
        } catch (error) {
            console.error("Error shuffling breaks:", error);
            this.showNotification("An error occurred while shuffling breaks.", "error");
        }
    },
    
    // --- COMPLIANCE LOGIC ---
    timeToMinutes(timeStr) {
        if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) return -1;
        let [hours, minutes] = timeStr.trim().split(':').map(Number);
        if (isNaN(hours) || isNaN(minutes)) return -1;
        // Shift times for overnight calculation (e.g., 01:00 becomes 25:00)
        if (hours < 20) { hours += 24; }
        return (hours * 60) + minutes;
    },
    
    isOnBreak(staff, timeSlot) {
        const startMins = this.timeToMinutes(staff.breakStart);
        const endMins = this.timeToMinutes(staff.breakEnd);
        const slotMins = this.timeToMinutes(timeSlot);
        if (startMins === -1 || endMins === -1 || slotMins === -1) return false;
        if (startMins === endMins) return false;
        return slotMins >= startMins && slotMins < endMins;
    },
    
    // --- GENERATION FLOW ---
    runRosterGeneration() {
        this.clearNotifications();
        document.getElementById('rosterContainer').innerHTML = '';
        const staff = this.staffDataCache.filter(s => s.attendance === 'Yes');
        if (staff.length === 0) { this.showNotification("Cannot generate roster. No staff marked as present.", 'error'); return; }

        const roster = this.initializeRoster();
        const staffAvailability = this.initializeStaffAvailability(staff);
        const shortfalls = [];
        const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
        
        this.assignCriticalDuties(roster, staffAvailability, isWeekend, shortfalls);
        this.assignStandardDuties(roster, staffAvailability, isWeekend, shortfalls);
        
        this.generatedRoster = roster;
        this.displayRoster(this.generatedRoster);
        
        if (shortfalls.length > 0) { 
            shortfalls.forEach(msg => this.showNotification(msg, 'warning')); 
        }
        this.saveRosterToFirestore(this.generatedRoster);
        this.addRosterActionButtons();
    },

    initializeRoster() { 
        const roster = {};
        this.LOCATIONS.forEach(loc => {
            roster[loc.name] = {};
            this.ROSTER_TIMES.forEach(time => {
                roster[loc.name][time] = new Array(loc.needed).fill("");
            });
        });
        return roster;
    },

    initializeStaffAvailability(staffList) { 
        const availability = {};
        staffList.forEach(staff => {
            availability[staff.id] = {data: staff, assignedSlots: []};
        });
        return availability;
    },

    findAvailableStaff(staffAvailability, timeSlot, locationName) {
        const shuffledStaff = Object.values(staffAvailability).sort(() => 0.5 - Math.random());
        for (const staff of shuffledStaff) {
            const onBreak = this.isOnBreak(staff.data, timeSlot);
            if (onBreak) continue;
            
            const isAlreadyAssigned = staff.assignedSlots.includes(timeSlot);
            const isEligible = locationName !== "HHMD" || staff.data.hhmd === "Yes";
            
            if (!isAlreadyAssigned && isEligible) {
                return staff;
            }
        }
        return null; // No staff found
    },

    assignStaff(roster, staff, timeSlot, locationName) {
        const slotIndex = roster[locationName][timeSlot].findIndex(id => id === "");
        if (slotIndex !== -1) {
            roster[locationName][timeSlot][slotIndex] = staff.data.id;
            staff.assignedSlots.push(timeSlot);
        }
    },
    
    // FIX: Replaced minified/broken version with readable, correct code.
    assignCriticalDuties(roster, staffAvailability, isWeekend, shortfalls) {
        for (const locName in this.CRITICAL_DUTIES) {
            if (isWeekend && locName === "Report Room") {
                continue;
            }
            const locationConfig = this.LOCATIONS.find(loc => loc.name === locName);
            this.CRITICAL_DUTIES[locName].forEach(timeSlot => {
                for (let i = 0; i < locationConfig.needed; i++) {
                    const staff = this.findAvailableStaff(staffAvailability, timeSlot, locName);
                    if (staff) {
                        this.assignStaff(roster, staff, timeSlot, locName);
                    } else {
                        shortfalls.push(`CRITICAL SHORTFALL: No staff for ${locName} at ${timeSlot}.`);
                    }
                }
            });
        }
    },

    // FIX: Replaced minified/broken version with readable, correct code.
    assignStandardDuties(roster, staffAvailability, isWeekend, shortfalls) {
        const standardDutyLocations = this.OUTPUT_ORDER.filter(locName => !this.CRITICAL_DUTIES.hasOwnProperty(locName));
        standardDutyLocations.forEach(locName => {
            const locationConfig = this.LOCATIONS.find(l => l.name === locName);
            this.ROSTER_TIMES.forEach(timeSlot => {
                for (let i = 0; i < locationConfig.needed; i++) {
                    if (roster[locName][timeSlot][i] === "") { // If slot is not already filled
                        const staff = this.findAvailableStaff(staffAvailability, timeSlot, locName);
                        if (staff) {
                            this.assignStaff(roster, staff, timeSlot, locName);
                        } else {
                            shortfalls.push(`Shortfall: ${locName} at ${timeSlot}.`);
                            break; // Stop trying to fill this slot if no one is available
                        }
                    }
                }
            });
        });
    },
    
    // --- DISPLAY & EXPORT ---
    displayRoster(roster) {
        const container = document.getElementById("rosterContainer");
        const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
        let staffOptionsHTML = '<option value="">--</option>' + presentStaff.map(s => `<option value="${s.id}">${s.id}</option>`).join('');

        let tableHTML = `<table id="editableRoster" class="min-w-full divide-y divide-gray-200 mt-4"><thead class="bg-gray-100"><tr><th class="sticky left-0 bg-gray-100 px-4 py-2 text-left text-sm font-semibold text-gray-700">Location</th>`;
        this.ROSTER_TIMES.forEach(time => { tableHTML += `<th class="px-4 py-2 text-center text-sm font-semibold text-gray-700">${time}</th>` });
        tableHTML += "</tr></thead><tbody class=\"bg-white\">";
        
        const isWeekend = ['Saturday', 'Sunday'].includes(document.getElementById('rosterDay').value);
        
        this.OUTPUT_ORDER.filter(loc => loc !== "Tango Papa").forEach(locName => {
            let isCombinedRow = locName === "Vertical Patrol";
            const location = this.LOCATIONS.find(l => l.name === locName);
            let locationCellHTML = isCombinedRow ? `Vertical Patrol<br>Tango Papa` : locName;
            
            tableHTML += `<tr class="border-b"><td class="sticky left-0 bg-white px-4 py-2 font-medium text-gray-900 ${isCombinedRow ? 'location-cell-multiline' : ''}">${locationCellHTML}</td>`;
            this.ROSTER_TIMES.forEach(timeSlot => {
                let cellContentHTML = '';
                let cellClass = '';
                let isApplicable = true;

                if (this.CRITICAL_DUTIES.hasOwnProperty(locName) && !this.CRITICAL_DUTIES[locName].includes(timeSlot)) {
                    isApplicable = false;
                }
                if (locName === "Report Room" && isWeekend) {
                    isApplicable = false;
                }

                if (isCombinedRow) {
                    const vpStaff = roster['Vertical Patrol'][timeSlot] || [];
                    const tpStaff = roster['Tango Papa'][timeSlot] || [];
                    const isVpCritical = this.CRITICAL_DUTIES['Vertical Patrol'].includes(timeSlot);
                    const isTpCritical = this.CRITICAL_DUTIES['Tango Papa'].includes(timeSlot);
                    
                    if (isVpCritical || isTpCritical) {
                        if (isVpCritical) {
                            const selectedId = vpStaff[0] || "";
                            cellContentHTML += `<select data-loc="Vertical Patrol" data-time="${timeSlot}" data-index="0" class="roster-select">${staffOptionsHTML.replace(`value="${selectedId}"`, `value="${selectedId}" selected`)}</select>`;
                        }
                        if(isTpCritical) {
                             const selectedId = tpStaff[0] || "";
                             cellContentHTML += `${isVpCritical ? '<br>' : ''}<select data-loc="Tango Papa" data-time="${timeSlot}" data-index="0" class="roster-select">${staffOptionsHTML.replace(`value="${selectedId}"`, `value="${selectedId}" selected`)}</select>`;
                        }
                    } else {
                       isApplicable = false;
                    }
                } else if(isApplicable) {
                    const assignedStaff = roster[locName][timeSlot] || [];
                    for(let i = 0; i < location.needed; i++) {
                        const selectedId = assignedStaff[i] || "";
                         if (i > 0) cellContentHTML += '<hr class="my-1 border-gray-200">';
                        cellContentHTML += `<select data-loc="${locName}" data-time="${timeSlot}" data-index="${i}" class="roster-select">${staffOptionsHTML.replace(`value="${selectedId}"`, `value="${selectedId}" selected`)}</select>`;
                    }
                }
                
                if (!isApplicable) {
                    cellClass = 'not-applicable';
                } else if (cellContentHTML.includes('value=""')) {
                     cellClass = 'empty-assignable-cell';
                }

                tableHTML += `<td class="roster-cell px-1 py-1 ${cellClass}">${cellContentHTML}</td>`;
            });
            tableHTML += "</tr>";
        });
        tableHTML += "</tbody></table>";
        container.innerHTML = tableHTML;
        
        document.querySelectorAll('.roster-select').forEach(sel => {
            sel.addEventListener('change', (e) => this.handleCellChange(e));
            this.validateCell(sel);
        });
    },

    handleCellChange(event) {
        const select = event.target;
        const locName = select.dataset.loc;
        const timeSlot = select.dataset.time;
        const index = parseInt(select.dataset.index, 10);
        const newStaffId = select.value;

        this.generatedRoster[locName][timeSlot][index] = newStaffId;
        this.validateCell(select);
        // Also re-validate any other cells that might now have a conflict
        this.validateAllCells(); 
        this.saveRosterToFirestore(this.generatedRoster);
    },
    
    validateCell(selectElement) {
        const staffId = selectElement.value;
        const timeSlot = selectElement.dataset.time;
        const cell = selectElement.closest('td');

        // Reset any previous conflict state
        cell.classList.remove('conflict-cell');

        if (!staffId) return; // Empty cell is not a conflict

        // Check for break conflicts
        const staffMember = this.staffDataCache.find(s => s.id === staffId);
        if (staffMember && this.isOnBreak(staffMember, timeSlot)) {
            cell.classList.add('conflict-cell');
            return;
        }

        // Check for double-booking conflicts
        const allSelectsInTimeslot = document.querySelectorAll(`.roster-select[data-time="${timeSlot}"]`);
        let assignmentCount = 0;
        allSelectsInTimeslot.forEach(sel => {
            if (sel.value === staffId) {
                assignmentCount++;
            }
        });
        
        if (assignmentCount > 1) {
             allSelectsInTimeslot.forEach(sel => {
                if (sel.value === staffId) {
                    sel.closest('td').classList.add('conflict-cell');
                }
            });
        }
    },

    validateAllCells() {
        document.querySelectorAll('.roster-select').forEach(sel => this.validateCell(sel));
        // A second pass is needed to clear conflicts that were resolved
        document.querySelectorAll('td.conflict-cell').forEach(cell => {
             const selects = cell.querySelectorAll('.roster-select');
             selects.forEach(select => this.validateCell(select));
        });
    },
    
    addRosterActionButtons() {
        document.getElementById("rosterActions")?.remove();
        let container = document.getElementById("rosterContainer");
        let buttonsHTML = `
            <div id="rosterActions" class="mt-6 flex flex-wrap gap-4 justify-center">
                <button id="regenerateRosterBtn" class="btn bg-gray-600 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-gray-700 flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>
                    Regenerate
                </button>
                <button id="copyTSVBtn" class="btn bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-blue-700">Copy for Excel</button>
                <button id="downloadPDFBtn" class="btn bg-red-600 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-red-700">Download PDF</button>
            </div>`;
        container.insertAdjacentHTML("beforeend", buttonsHTML);
        
        document.getElementById("regenerateRosterBtn").addEventListener("click", () => this.runRosterGeneration());
        document.getElementById("copyTSVBtn").addEventListener("click", () => this.copyTSV());
        document.getElementById("downloadPDFBtn").addEventListener("click", () => this.downloadPDF());
    },

    copyTSV() {
        if (!this.generatedRoster) {
            this.showNotification("No roster to copy.", "error");
            return;
        }
        let tsvContent = "Location\t" + this.ROSTER_TIMES.join("\t") + "\n";
        this.OUTPUT_ORDER.forEach(locName => {
            const rowData = this.ROSTER_TIMES.map(time => this.generatedRoster[locName][time].join(" | ")).join("\t");
            tsvContent += `${locName}\t${rowData}\n`;
        });
        navigator.clipboard.writeText(tsvContent).then(
            () => this.showNotification("Roster copied to clipboard!", "success"),
            () => this.showNotification("Failed to copy.", "error")
        );
    },

    downloadPDF() {
        if (!this.generatedRoster) { this.showNotification('No roster to download.', 'error'); return; }
        try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: "landscape", unit: "mm", format: "a4" });
            const rosterDate = document.getElementById('rosterDate').value; 
            const rosterDay = document.getElementById('rosterDay').value;
            doc.setFontSize(16); doc.text(`Staff Roster - ${rosterDate} (${rosterDay})`, 14, 15);

            const pdfBody = this.OUTPUT_ORDER.filter(loc => loc !== 'Tango Papa').map(locName => {
                let displayName = locName;
                const rowData = this.ROSTER_TIMES.map(time => {
                    let cellContent = (this.generatedRoster[locName][time] || []).filter(id => id).join(' | ');
                    if (locName === 'Vertical Patrol') {
                        displayName = 'Vertical Patrol\nTango Papa';
                        const vpStaff = this.generatedRoster['Vertical Patrol'][time] || [];
                        const tpStaff = this.generatedRoster['Tango Papa'][time] || [];
                        const isVpCritical = this.CRITICAL_DUTIES['Vertical Patrol'].includes(time);
                        const isTpCritical = this.CRITICAL_DUTIES['Tango Papa'].includes(time);
                        let vpText = isVpCritical ? vpStaff.filter(id => id).join(', ') : '';
                        let tpText = isTpCritical ? tpStaff.filter(id => id).join(', ') : '';
                        cellContent = `${vpText}${vpText && tpText ? '\n' : ''}${tpText}`;
                    }
                    return cellContent;
                });
                return [displayName, ...rowData];
            });
            const rosterHead = [['Location', ...this.ROSTER_TIMES]];
            doc.autoTable({ head: rosterHead, body: pdfBody, startY: 22, theme: 'grid', styles: { fontSize: 6, cellPadding: 1, halign: 'center', valign: 'middle' }, headStyles: { fillColor: [45, 55, 72], textColor: 255, fontSize: 7, halign: 'center' }, columnStyles: { 0: { fontStyle: "bold", cellWidth: 28, halign: 'left' } } });
            
            const presentStaff = this.staffDataCache.filter(s => s.attendance === 'Yes');
            const staffHead = [['Staff ID', 'Name', 'Break Time']];
            const staffBody = presentStaff.map(staff => [ staff.id, staff.name, `${staff.breakStart} - ${staff.breakEnd}` ]);
            doc.autoTable({ head: staffHead, body: staffBody, startY: doc.autoTable.previous.finalY + 8, theme: 'striped', styles: { fontSize: 8, cellPadding: 1.5 }, headStyles: { fillColor: [124, 58, 237], textColor: 255 }, columnStyles: { 1: { cellWidth: 40 } }, margin: { left: 14 } });
            
            const pdfBlob = doc.output('blob');
            const blobUrl = URL.createObjectURL(pdfBlob);
            document.getElementById('pdfDownloadLink').href = blobUrl;
            document.getElementById('pdfDownloadLink').download = `roster_${rosterDate}.pdf`;
            document.getElementById('pdfPreview').src = blobUrl;
            document.getElementById('pdfModal').style.display = 'flex';
            this.showNotification('PDF generated. Preview is ready.', 'success');
        } catch (e) { 
            console.error("PDF Generation/Download Error:", e); 
            this.showNotification('An error occurred while creating the PDF.', 'error'); 
        }
    },

    closePdfModal() {
        const downloadLink = document.getElementById('pdfDownloadLink');
        const previewFrame = document.getElementById('pdfPreview');
        if (downloadLink.href.startsWith('blob:')) { URL.revokeObjectURL(downloadLink.href); }
        downloadLink.href = '#';
        previewFrame.src = 'about:blank';
        document.getElementById('pdfModal').style.display = 'none';
    },

    clearNotifications() { 
        document.getElementById("notification-container").innerHTML="";
    },

    showNotification(message, type = "info") {
        const container = document.getElementById("notification-container");
        const colors = {success: "green", error: "red", warning: "yellow", info: "blue"};
        const alertDiv = document.createElement("div");
        alertDiv.className = `border-l-4 p-4 bg-${colors[type]}-100 border-${colors[type]}-500 text-${colors[type]}-700`;
        alertDiv.innerHTML = `<p class="font-bold">${type.charAt(0).toUpperCase() + type.slice(1)}</p><p>${message}</p>`;
        container.appendChild(alertDiv);
        setTimeout(() => {
            alertDiv.style.transition = "opacity 0.5s ease";
            alertDiv.style.opacity = "0";
            setTimeout(() => alertDiv.remove(), 500);
        }, 5000);
    }
};

rosterSystem.init();

</script>
</body>
</html>
