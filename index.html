<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Staff Roster Management System CP</title>
  
  <!-- External libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>

  <style>
    :root {
      --primary-color: #4f46e5;
      --primary-hover: #4338ca;
      --secondary-color: #6B7280;
      --secondary-hover: #4B5563;
      --success-color: #10B981;
      --warning-color: #F59E0B;
      --danger-color: #EF4444;
      --light-bg: #f3f4f6;
      --border-color: #e5e7eb;
      --text-color: #1f2937;
      --text-light: #6B7280;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px; 
      text-align: center;
      font-size: 14px;
      background-color: var(--light-bg);
      color: var(--text-color);
      line-height: 1.5;
    }
    
    h2 { 
      color: var(--primary-color);
      margin-bottom: 25px;
      font-weight: 600;
    }
    
    h3, h4 {
      color: var(--text-color);
      margin: 20px 0 10px 0;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 15px;
    }
    
    .card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    
    /* Layout components */
    .date-container, .gap-policy-container {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .date-container > div, .gap-policy-container > div {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    /* Tables */
    table { 
      width: 100%; 
      border-collapse: collapse; 
      margin: 20px 0;
      background: white;
      border-radius: 6px;
      overflow: hidden;
    }
    
    th, td { 
      border: 1px solid var(--border-color);
      padding: 10px 8px; 
      text-align: center; 
    }
    
    th { 
      background-color: var(--primary-color);
      color: white;
      font-weight: 600;
    }
    
    tr:nth-child(even) {
      background-color: rgba(0,0,0,0.02);
    }
    
    tr:hover {
      background-color: rgba(0,0,0,0.04);
    }
    
    /* Form elements */
    input, select { 
      padding: 6px 8px; 
      text-align: center; 
      font-size: 13px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      transition: border-color 0.2s;
    }
    
    input:focus, select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
    }
    
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    /* Button styles */
    .button-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin: 20px 0;
      align-items: center;
    }
    
    .button-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .roster-btn {
      background-color: var(--primary-color);
      color: white;
      padding: 8px 16px;
      font-size: 13px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }
    
    .roster-btn:hover { 
      background-color: var(--primary-hover);
      transform: translateY(-1px);
    }
    
    .roster-btn:active {
      transform: translateY(1px);
    }
    
    .remove-btn {
      background-color: var(--danger-color);
      color: white;
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    .remove-btn:hover { 
      opacity: 0.9;
    }
    
    /* Specific elements */
    .break-time-container { 
      display: flex; 
      align-items: center; 
      gap: 5px; 
    }
    
    .shortfall-note { 
      color: var(--danger-color);
      font-weight: bold;
      font-size: 12px;
    }
    
    #importFile { 
      display: none; 
    }
    
    #rosterContainer { 
      overflow-x: auto; 
    }
    
    .staff-input, .time-input, .staff-select { 
      font-size: 13px; 
    }
    
    #breakListContainer {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 220px;
      max-height: 350px;
      overflow: auto;
      background-color: white;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 12px;
      font-size: 12px;
      text-align: left;
      cursor: move;
      z-index: 1000;
      transition: opacity 0.3s;
    }
    
    #breakListContainer.hidden {
      opacity: 0.2;
    }
    
    #breakListContainer:hover {
      opacity: 1;
    }
    
    /* Status indicators */
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    
    .status-success {
      background-color: var(--success-color);
    }
    
    .status-warning {
      background-color: var(--warning-color);
    }
    
    .status-danger {
      background-color: var(--danger-color);
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .date-container, .gap-policy-container {
        flex-direction: column;
        align-items: center;
      }
      
      .button-row {
        flex-direction: column;
        width: 100%;
        max-width: 200px;
      }
      
      .roster-btn {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h2>Staff Roster Management System CP</h2>

    <!-- Date, Day, Staff Count -->
    <div class="card">
      <div class="date-container">
        <div>
          <label for="rosterDate">Roster Date:</label>
          <input type="date" id="rosterDate">
        </div>
        <div>
          <label for="rosterDay">Day:</label>
          <select id="rosterDay">
            <option value="Monday">Monday</option>
            <option value="Tuesday">Tuesday</option>
            <option value="Wednesday">Wednesday</option>
            <option value="Thursday">Thursday</option>
            <option value="Friday">Friday</option>
            <option value="Saturday">Saturday</option>
            <option value="Sunday">Sunday</option>
          </select>
        </div>
        <div>
          <label>Working Staff:</label>
          <span id="staffCount">0</span>
        </div>
      </div>

      <!-- Gap Policy: Slider from 30 to 120 minutes -->
      <div class="gap-policy-container">
        <div>
          <label for="gapThreshold">Gap Threshold (minutes): </label>
          <input type="range" id="gapThreshold" min="30" max="120" step="15" value="120">
          <span id="gapThresholdValue">120</span>
        </div>
      </div>
    </div>

    <!-- Staff Table -->
    <div class="card">
      <h3>Staff Management</h3>
      <div class="table-responsive">
        <table id="staffTable">
          <thead>
            <tr>
              <th>Staff ID</th>
              <th>Name</th>
              <th>Break Time</th>
              <th>HHMD Eligible</th>
              <th>Attendance</th>
              <th>Lock</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <!-- Action Buttons -->
      <div class="button-container">
        <div class="button-row">
          <button class="roster-btn" id="addStaffBtn">Add Staff</button>
          <button class="roster-btn" id="importDataBtn">Import Data</button>
          <button class="roster-btn" id="exportDataBtn">Export Data</button>
        </div>
        <div class="button-row">
          <button class="roster-btn" id="shuffleBreaksBtn">Shuffle Breaks</button>
          <button class="roster-btn" id="generateRosterBtn">Generate Roster</button>
          <button class="roster-btn" id="copyTSVBtn">Copy Roster</button>
        </div>
        <div class="button-row">
          <button class="roster-btn" id="downloadCSVBtn">CSV</button>
          <button class="roster-btn" id="downloadPDFBtn">PDF</button>
          <button class="roster-btn" id="toggleBreakNoteBtn">Toggle Break Note</button>
        </div>
      </div>
    </div>

    <!-- Hidden file input for importData() -->
    <input type="file" id="importFile" accept=".json" />

    <!-- Generated Roster Display -->
    <div class="card">
      <h3>Generated Roster</h3>
      <div id="rosterContainer"></div>
    </div>

    <!-- Roster Health Summary -->
    <div class="card">
      <h4>Roster Health</h4>
      <div id="notesContainer"></div>
    </div>
  </div>

  <!-- Floating Break Time Note (draggable) -->
  <div id="breakListContainer">
    <strong>Staff Break Times</strong><br><br>
  </div>

  <!-- Scripts will be loaded in separate files -->
</body>
</html>

/**
 * Staff Roster Management System - Core Module
 * Contains constants, configuration, and core functionality
 */

// Core constants
const STORAGE_KEY = 'staffListData_v2'; // Updated key for new version
const ROSTER_TIMES = [
  "20:00", "20:30", "21:00", "22:00", "23:00",
  "00:00", "01:00", "01:30", "02:00", "03:00",
  "04:00", "05:00", "06:00", "07:00", "07:30"
];

const PRIORITY = [
  { location: "Pass Counter", needed: 2 },
  { location: "HHMD", needed: 1 },
  { location: "Lobby", needed: 2 },
  { location: "Guard House", needed: 1 },
  { location: "Vertical Patrol", needed: 1 },
  { location: "Report Room", needed: 1 },
  { location: "Tango Papa", needed: 1 }
];

const OUTPUT_ORDER = [
  "Pass Counter", "HHMD", "Lobby", "Guard House",
  "Vertical Patrol", "Report Room", "Tango Papa"
];

const BREAK_TIME_POOL = [
  "20:00-21:30", "21:30-23:30", "22:00-00:00",
  "23:00-01:00", "00:00-02:00", "01:30-03:30",
  "02:00-04:00", "03:00-05:00", "04:00-06:00",
  "05:00-07:00", "06:00-08:00"
];

const CRITICAL_LOCATIONS = {
  "Vertical Patrol": ["20:30", "23:00", "01:30", "06:00"],
  "Report Room": ["20:00", "21:00"],
  "Tango Papa": ["07:30"]
};

// Roster system object
const rosterSystem = {
  /**
   * Initializes the roster management system
   */
  init: function() {
    console.log("Initializing roster system v2.0...");
    try {
      // Check for required HTML elements
      const requiredElements = [
        'rosterDate', 'rosterDay', 'gapThreshold', 'staffCount', 'staffTable',
        'addStaffBtn', 'importDataBtn', 'exportDataBtn', 'shuffleBreaksBtn',
        'generateRosterBtn', 'copyTSVBtn', 'downloadCSVBtn', 'downloadPDFBtn',
        'toggleBreakNoteBtn', 'importFile', 'rosterContainer', 'notesContainer',
        'breakListContainer'
      ];
      
      const missingElements = requiredElements.filter(id => !document.getElementById(id));
      
      if (missingElements.length > 0) {
        console.error("Missing HTML elements:", missingElements);
        this.showError(`Missing required HTML elements: ${missingElements.join(', ')}`);
        return;
      }

      // Verify required libraries
      if (typeof jsPDF === "undefined") {
        console.warn("jsPDF library failed to load (needed for PDF export)");
        this.showWarning("PDF export functionality may be unavailable due to missing jsPDF library.");
      }

      // Initialize date/day with current date
      this.initializeDateAndDay();
      
      // Set up event listeners
      this.setupEventListeners();
      
      // Make break list draggable
      this.makeDraggable(document.getElementById('breakListContainer'));
      
      // Load existing staff list from storage
      this.loadStaffList();
      
      // Update the displayed break list
      this.displayBreakList();
      
      console.log("Roster system v2.0 initialized successfully!");
      this.showSuccess("System initialized successfully");
    } catch (e) {
      console.error("Initialization error:", e);
      this.showError(`Failed to initialize: ${e.message}`);
    }
  },
  
  /**
   * Set current date and day in form
   */
  initializeDateAndDay: function() {
    const today = new Date();
    const dateStr = today.toISOString().split('T')[0];
    document.getElementById('rosterDate').value = dateStr;
    
    const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
    const currentDay = days[today.getDay()];
    document.getElementById('rosterDay').value = currentDay;
  },

  /**
   * Set up all event listeners for the system
   */
  setupEventListeners: function() {
    // Gap threshold slider events
    const gapSlider = document.getElementById("gapThreshold");
    const gapDisplay = document.getElementById("gapThresholdValue");
    
    gapSlider.addEventListener("input", function() {
      gapDisplay.innerText = this.value;
    });
    
    gapSlider.addEventListener("change", () => {
      if (window.generatedRosterData) {
        this.generateRoster();
      }
    });
    
    // Button event listeners
    document.getElementById('addStaffBtn').addEventListener('click', () => this.addStaff());
    document.getElementById('importDataBtn').addEventListener('click', () => this.importData());
    document.getElementById('exportDataBtn').addEventListener('click', () => this.exportData());
    document.getElementById('shuffleBreaksBtn').addEventListener('click', () => this.shuffleBreakTimes());
    document.getElementById('generateRosterBtn').addEventListener('click', () => this.generateRoster());
    document.getElementById('copyTSVBtn').addEventListener('click', () => this.copyTSV());
    document.getElementById('downloadCSVBtn').addEventListener('click', () => this.downloadRoster('csv'));
    document.getElementById('downloadPDFBtn').addEventListener('click', () => this.downloadRoster('pdf'));
    document.getElementById('toggleBreakNoteBtn').addEventListener('click', () => this.toggleBreakNote());
    
    // Handle date/day changes
    document.getElementById('rosterDay').addEventListener('change', () => {
      if (window.generatedRosterData) {
        this.generateRoster();
      }
    });
  },
  
  /**
   * Show success message to the user
   * @param {string} message - The message to display
   */
  showSuccess: function(message) {
    this.showNotification(message, 'success');
  },
  
  /**
   * Show error message to the user
   * @param {string} message - The message to display
   */
  showError: function(message) {
    this.showNotification(message, 'error');
  },
  
  /**
   * Show warning message to the user
   * @param {string} message - The message to display
   */
  showWarning: function(message) {
    this.showNotification(message, 'warning');
  },
  
  /**
   * Display a notification to the user
   * @param {string} message - The message to display
   * @param {string} type - The type of notification: 'success', 'error', 'warning'
   */
  showNotification: function(message, type = 'info') {
    // For now, just use alert, but this can be improved with a custom notification system
    const typeMap = {
      'success': '‚úÖ ',
      'error': '‚ùå ',
      'warning': '‚ö†Ô∏è ',
      'info': '‚ÑπÔ∏è '
    };
    
    const prefix = typeMap[type] || '';
    alert(prefix + message);
  },
  
  /**
   * Calculate time in minutes from a time string
   * @param {string} timeStr - Time in format "HH:MM"
   * @returns {number} - Time converted to minutes
   */
  timeToMinutes: function(timeStr) {
    if (!timeStr || typeof timeStr !== "string" || !timeStr.match(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)) {
      console.warn(`Invalid time format: ${timeStr}`);
      return 0;
    }
    
    const [hours, minutes] = timeStr.split(":").map(Number);
    
    // Adjust hours for after midnight (treat 00:00-07:59 as 24:00-31:59)
    const adjustedHours = hours < 8 ? hours + 24 : hours;
    
    // Convert to minutes since 20:00
    return (adjustedHours - 20) * 60 + minutes;
  },
  
  /**
   * Parse a break time string into start and end minutes
   * @param {string} breakTime - Break time in format "HH:MM-HH:MM"
   * @returns {Object} - Object with start and end times in minutes
   */
  parseBreakTime: function(breakTime) {
    if (!breakTime || !breakTime.includes("-")) {
      return { start: 0, end: 0 };
    }
    
    const [startStr, endStr] = breakTime.split("-");
    return {
      start: this.timeToMinutes(startStr),
      end: this.timeToMinutes(endStr)
    };
  },
  
  /**
   * Check if a location applies to a given time slot
   * @param {string} loc - Location name
   * @param {string} slot - Time slot
   * @param {boolean} isWeekend - Whether it's a weekend
   * @returns {boolean} - Whether the location applies
   */
  locationApplies: function(loc, slot, isWeekend) {
    if (loc === "Tango Papa") return slot === "07:30";
    if (loc === "Pass Counter" && slot === "07:30") return false;
    if (loc === "Vertical Patrol") return ["20:30", "23:00", "01:30", "06:00"].includes(slot);
    if (loc === "Report Room") {
      if (isWeekend) return false;
      return ["20:00", "21:00"].includes(slot);
    }
    return true;
  },
  
  /**
   * Make an element draggable
   * @param {HTMLElement} el - The element to make draggable
   */
  makeDraggable: function(el) {
    if (!el) return;
    
    let pos = { top: 0, left: 0, x: 0, y: 0 };
    
    const mouseDownHandler = function(e) {
      pos = {
        left: el.offsetLeft,
        top: el.offsetTop,
        x: e.clientX,
        y: e.clientY,
      };
      document.addEventListener('mousemove', mouseMoveHandler);
      document.addEventListener('mouseup', mouseUpHandler);
      
      // Change cursor style
      el.style.cursor = 'grabbing';
      el.style.userSelect = 'none';
    };
    
    const mouseMoveHandler = function(e) {
      const dx = e.clientX - pos.x;
      const dy = e.clientY - pos.y;
      
      // Calculate new position
      let newLeft = pos.left + dx;
      let newTop = pos.top + dy;
      
      // Constrain to window
      const maxX = window.innerWidth - el.offsetWidth;
      const maxY = window.innerHeight - el.offsetHeight;
      
      newLeft = Math.max(0, Math.min(newLeft, maxX));
      newTop = Math.max(0, Math.min(newTop, maxY));
      
      el.style.left = newLeft + 'px';
      el.style.top = newTop + 'px';
    };
    
    const mouseUpHandler = function() {
      document.removeEventListener('mousemove', mouseMoveHandler);
      document.removeEventListener('mouseup', mouseUpHandler);
      
      // Reset cursor style
      el.style.cursor = 'grab';
      el.style.userSelect = '';
    };
    
    // Attach the handlers
    el.addEventListener('mousedown', mouseDownHandler);
    
    // Set initial styles
    el.style.cursor = 'grab';
    el.style.position = 'fixed';
  }
};

// Export the rosterSystem for use in other modules
window.RosterApp = rosterSystem;

/**
 * Staff Roster Management System - Staff Management Module
 * Handles adding, removing, and managing staff data
 */

// Extend the rosterSystem with staff management functions
Object.assign(rosterSystem, {
  /**
   * Load staff list from local storage
   */
  loadStaffList: function() {
    const stored = localStorage.getItem(STORAGE_KEY);
    const tbody = document.getElementById("staffTable").querySelector("tbody");
    
    if (stored) {
      try {
        const staffList = JSON.parse(stored);
        tbody.innerHTML = "";
        
        if (Array.isArray(staffList)) {
          staffList.forEach(staff => {
            tbody.innerHTML += this.getStaffRowHTML(staff);
          });
          this.showSuccess(`Loaded ${staffList.length} staff members from storage`);
        } else {
          throw new Error("Invalid staff data format");
        }
      } catch (error) {
        console.error("Error loading staff data:", error);
        this.showWarning("Could not load saved staff data. Starting with empty roster.");
        this.addStaff(); // Add one empty row
      }
    } else {
      // No stored data, start with one empty staff member
      this.addStaff();
    }
    
    this.addListenersToAllRows();
    this.updateStaffCount();
  },

  /**
   * Save current staff list to local storage
   */
  saveStaffList: function() {
    try {
      const staffList = this.getCurrentStaffList();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(staffList));
      return true;
    } catch (error) {
      console.error("Error saving staff list:", error);
      this.showError("Failed to save staff list: " + error.message);
      return false;
    }
  },

  /**
   * Get staff list from current table
   * @returns {Array} - Array of staff objects
   */
  getCurrentStaffList: function() {
    const rows = document.getElementById("staffTable").querySelector("tbody").rows;
    const staffList = [];
    
    for (let row of rows) {
      try {
        const startTime = row.cells[2].querySelectorAll("input[type='time']")[0].value;
        const endTime = row.cells[2].querySelectorAll("input[type='time']")[1].value;
        
        const formatTime = (time) => {
          if (!time) return "00:00";
          const [hours, minutes] = time.split(":").map(Number);
          return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        };
        
        const breakTime = `${formatTime(startTime)}-${formatTime(endTime)}`;
        
        const assigned = row.dataset.assigned ? JSON.parse(row.dataset.assigned) : [];
        
        const staffData = {
          staffID: row.cells[0].querySelector("input").value.trim(),
          name: row.cells[1].querySelector("input").value.trim(),
          breakTime: breakTime,
          hhmdEligible: row.cells[3].querySelector("select").value,
          attendance: row.cells[4].querySelector("select").value,
          locked: row.cells[5].querySelector("input[type='checkbox']").checked,
          assigned: assigned
        };
        
        staffList.push(staffData);
      } catch (error) {
        console.error("Error processing staff row:", error);
      }
    }
    
    return staffList;
  },

  /**
   * Generate HTML for a staff row
   * @param {Object} staff - Staff data object
   * @returns {string} - HTML string for the staff row
   */
  getStaffRowHTML: function(staff = {}) {
    let [startVal, endVal] = ["21:30", "23:30"]; // Default values
    
    if (staff.breakTime && staff.breakTime.includes("-")) {
      [startVal, endVal] = staff.breakTime.split("-");
    }
    
    return `
      <tr data-assigned='${JSON.stringify(staff.assigned || [])}'>
        <td><input type="text" value="${staff.staffID || ''}" class="staff-input" placeholder="ID"></td>
        <td><input type="text" value="${staff.name || ''}" class="staff-input" placeholder="Name"></td>
        <td>
          <div class="break-time-container">
            <input type="time" value="${startVal}" step="1800" class="time-input">
            <span>-</span>
            <input type="time" value="${endVal}" step="1800" class="time-input">
          </div>
        </td>
        <td>
          <select class="staff-select">
            <option value="Yes" ${staff.hhmdEligible==="Yes"?"selected":""}>Yes</option>
            <option value="No" ${staff.hhmdEligible==="No"?"selected":""}>No</option>
          </select>
        </td>
        <td>
          <select class="staff-select">
            <option value="Yes" ${staff.attendance==="Yes"?"selected":""}>Yes</option>
            <option value="No" ${staff.attendance==="No"?"selected":""}>No</option>
          </select>
        </td>
        <td>
          <input type="checkbox" ${staff.locked ? "checked" : ""} title="Lock this staff member's assignments">
        </td>
        <td><button class="remove-btn" data-staff-id="${staff.staffID || ''}">Remove</button></td>
      </tr>
    `;
  },

  /**
   * Add a new staff member row
   */
  addStaff: function() {
    const tbody = document.getElementById("staffTable").querySelector("tbody");
    
    // Create new staff object with default values
    const newStaff = {
      staffID: "",
      name: "",
      breakTime: "21:30-23:30",
      hhmdEligible: "No",
      attendance: "Yes",
      locked: false,
      assigned: []
    };
    
    // Add the new row to the table
    tbody.insertAdjacentHTML("beforeend", this.getStaffRowHTML(newStaff));
    
    // Add event listeners to the new row
    this.addListenersToAllRows();
    
    // Save the updated staff list
    this.saveStaffList();
    
    // Update the staff count display
    this.updateStaffCount();
  },

  /**
   * Remove a staff row
   * @param {HTMLElement} button - The clicked remove button
   */
  removeRow: function(button) {
    const row = button.closest("tr");
    const staffID = button.getAttribute('data-staff-id');
    
    // Confirm removal if staff ID exists
    if (staffID && !confirm(`Remove staff ${staffID}?`)) {
      return;
    }
    
    // Remove the row from the table
    row.remove();
    
    // Save the updated staff list
    this.saveStaffList();
    
    // Update the staff count display
    this.updateStaffCount();
  },

  /**
   * Add event listeners to all staff table rows
   */
  addListenersToAllRows: function() {
    const tbody = document.getElementById("staffTable").querySelector("tbody");
    const self = this;
    
    // Add change listeners to all inputs and selects in the table
    const inputs = tbody.querySelectorAll("input, select");
    inputs.forEach(inp => {
      // Remove existing listener to prevent duplicates
      inp.removeEventListener("change", inp._changeHandler);
      
      // Create and store listener function
      inp._changeHandler = function() {
        self.saveStaffList();
        self.updateStaffCount();
        self.displayBreakList();
      };
      
      // Add the listener
      inp.addEventListener("change", inp._changeHandler);
    });
    
    // Add click listeners to all remove buttons
    const removeButtons = tbody.querySelectorAll(".remove-btn");
    removeButtons.forEach(btn => {
      // Remove existing listener to prevent duplicates
      btn.removeEventListener("click", btn._clickHandler);
      
      // Create and store listener function
      btn._clickHandler = function() {
        self.removeRow(this);
      };
      
      // Add the listener
      btn.addEventListener("click", btn._clickHandler);
    });
  },

  /**
   * Update the displayed staff count
   */
  updateStaffCount: function() {
    const staffList = this.getCurrentStaffList();
    const workingCount = staffList.filter(st => st.attendance === "Yes").length;
    
    // Update display
    document.getElementById("staffCount").textContent = workingCount;
    
    // Give visual feedback based on count
    const countElement = document.getElementById("staffCount");
    
    if (workingCount < 5) {
      countElement.style.color = "red";
      countElement.title = "Warning: Low staff count";
    } else if (workingCount < 8) {
      countElement.style.color = "orange";
      countElement.title = "Warning: Minimal staff count";
    } else {
      countElement.style.color = "green";
      countElement.title = "Sufficient staff count";
    }
  },

  /**
   * Shuffle break times for all unlocked staff
   */
  shuffleBreakTimes: function() {
    const staffList = this.getCurrentStaffList();
    let changedCount = 0;
    
    staffList.forEach(st => {
      // Only shuffle for working staff that aren't locked
      if (st.attendance === "Yes" && !st.locked) {
        const randomIndex = Math.floor(Math.random() * BREAK_TIME_POOL.length);
        st.breakTime = BREAK_TIME_POOL[randomIndex];
        changedCount++;
      }
    });
    
    // Apply the updated list to the table
    this.applyStaffListToTable(staffList);
    
    // Save changes
    this.saveStaffList();
    
    // Update the break list display
    this.displayBreakList();
    
    // Notify user
    this.showSuccess(`Break times shuffled for ${changedCount} staff members!`);
  },

  /**
   * Apply a staff list array to the table
   * @param {Array} staffList - Array of staff objects
   */
  applyStaffListToTable: function(staffList) {
    const tbody = document.getElementById("staffTable").querySelector("tbody");
    
    // Clear the table
    tbody.innerHTML = "";
    
    // Add each staff member to the table
    staffList.forEach(staff => {
      tbody.innerHTML += this.getStaffRowHTML(staff);
    });
    
    // Add event listeners to the rows
    this.addListenersToAllRows();
    
    // Update the staff count display
    this.updateStaffCount();
  },

  /**
   * Display the list of staff break times
   */
  displayBreakList: function() {
    const container = document.getElementById("breakListContainer");
    const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
    
    // Build the HTML content
    let html = "<strong>Staff Break Times</strong><br><br>";
    
    if (staffList.length === 0) {
      html += "<em>No staff scheduled</em>";
    } else {
      // Sort staff by break start time
      staffList.sort((a, b) => {
        const timeA = this.parseBreakTime(a.breakTime);
        const timeB = this.parseBreakTime(b.breakTime);
        return timeA.start - timeB.start;
      });
      
      // Generate list
      staffList.forEach(st => {
        html += `<strong>${st.staffID || "??"}</strong> (${st.name || "??"}): ${st.breakTime}`;
        
        // Show locked indicator
        if (st.locked) {
          html += ' üîí';
        }
        
        html += "<br>";
      });
    }
    
    // Update the container
    container.innerHTML = html;
  },

  /**
   * Toggle the visibility of the break note
   */
  toggleBreakNote: function() {
    const note = document.getElementById("breakListContainer");
    note.classList.toggle("hidden");
  },

  /**
   * Import staff data from a JSON file
   */
  importData: function() {
    const fileInput = document.getElementById('importFile');
    fileInput.value = ""; // Clear the input
    
    fileInput.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Read the file
        const text = await file.text();
        const importedStaff = JSON.parse(text);
        
        // Validate the data
        if (!Array.isArray(importedStaff)) {
          throw new Error("Invalid JSON structure. Must be an array of staff objects.");
        }
        
        // Validate break time format
        importedStaff.forEach(staff => {
          if (!staff.breakTime || !staff.breakTime.match(/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/)) {
            throw new Error(`Invalid break time format for staff ${staff.staffID}: ${staff.breakTime}`);
          }
        });
        
        // Store the imported data
        localStorage.setItem(STORAGE_KEY, JSON.stringify(importedStaff));
        
        // Reload the staff list
        this.loadStaffList();
        
        // Update the break list display
        this.displayBreakList();
        
        // Notify the user
        this.showSuccess(`Imported ${importedStaff.length} staff records successfully.`);
      } catch (err) {
        console.error("Import error:", err);
        this.showError("Error importing data: " + err.message);
      }
    };
    
    // Trigger the file input
    fileInput.click();
  },

  /**
   * Export staff data to a JSON file
   */
  exportData: function() {
    try {
      const staffList = this.getCurrentStaffList();
      
      if (staffList.length === 0) {
        this.showWarning("No staff data to export.");
        return;
      }
      
      // Format the JSON with proper indentation
      const jsonStr = JSON.stringify(staffList, null, 2);
      
      // Create a Blob with the data
      const blob = new Blob([jsonStr], { type: "application/json" });
      
      // Create a download URL
      const url = URL.createObjectURL(blob);
      
      // Create and trigger a download link
      const link = document.createElement("a");
      const date = new Date().toISOString().split('T')[0];
      link.href = url;
      link.download = `staff_data_${date}.json`;
      link.click();
      
      // Clean up the URL object
      URL.revokeObjectURL(url);
      
      // Notify the user
      this.showSuccess(`Exported ${staffList.length} staff records successfully.`);
    } catch (error) {
      console.error("Export error:", error);
      this.showError("Error exporting data: " + error.message);
    }
  }
});

/**
 * Staff Roster Management System - Roster Generation Module
 * Handles the algorithms for generating and validating rosters
 */

// Extend the rosterSystem with roster generation functions
Object.assign(rosterSystem, {
  /**
   * Generate a roster based on current staff and requirements
   */
  generateRoster: function() {
    // Determine if it's a weekend
    const dayValue = document.getElementById("rosterDay").value;
    const isWeekend = (dayValue === "Saturday" || dayValue === "Sunday");
    
    // Get available staff
    let staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
    
    if (staffList.length === 0) {
      this.showError("Please add staff members before generating roster.");
      return;
    }
    
    // Reset assignments for unlocked staff
    staffList.forEach(st => { 
      if (!st.locked) st.assigned = []; 
    });
    
    // Initialize roster and shortfalls array
    let roster = {};
    let shortfalls = [];
    
    // Initialize each location in the roster
    PRIORITY.forEach(({location}) => { 
      roster[location] = {}; 
    });

    // First pass: Assign staff to critical locations
    this.assignCriticalLocations(roster, staffList, isWeekend, shortfalls);
    
    // Check for critical shortfalls after first pass
    this.checkCriticalShortfalls(roster, isWeekend, shortfalls);

    // Second pass: Fill remaining slots based on priority
    for (let p of PRIORITY) {
      const loc = p.location;
      const needed = p.needed;
      
      for (let slot of ROSTER_TIMES) {
        // Skip slots that don't apply
        if (slot === "07:30" && loc !== "Tango Papa") continue;
        if (!this.locationApplies(loc, slot, isWeekend)) continue;
        
        // Initialize the slot if needed
        if (!roster[loc][slot]) roster[loc][slot] = "";
        
        // Count currently assigned staff
        const assignedIDs = roster[loc][slot].split(",").map(s => s.trim()).filter(Boolean);
        const assignedCount = assignedIDs.length;
        
        // Calculate how many more staff needed
        const stillNeeded = needed - assignedCount;
        
        if (stillNeeded <= 0) continue; // Already have enough staff
        
        // Try to assign the needed number of staff
        for (let i = 0; i < stillNeeded; i++) {
          // Find an available staff member
          const availableStaff = this.findAvailableStaff(staffList, slot, loc);
          
          if (availableStaff && !this.wouldCauseConflict(roster, availableStaff, slot, loc)) {
            // Add staff to roster
            roster[loc][slot] += roster[loc][slot] ? `, ${availableStaff.staffID}` : availableStaff.staffID;
            
            // Record the assignment
            availableStaff.assigned.push({ slot, location: loc });
          } else {
            // No suitable staff found - record shortfall
            if (assignedCount + i === 0) {
              shortfalls.push(`CRITICAL: No staff available for ${loc} at ${slot}`);
            } else {
              shortfalls.push(`Shortfall: ${loc} at ${slot} has only ${assignedCount + i}/${needed} staff`);
            }
            break;
          }
        }
      }
    }

    // Store the generated roster data for later use
    window.generatedRosterData = {};
    
    OUTPUT_ORDER.forEach(loc => {
      window.generatedRosterData[loc] = {};
      
      ROSTER_TIMES.forEach(slot => {
        const assignedIDs = roster[loc][slot] 
          ? roster[loc][slot].split(",").map(s => s.trim()).filter(Boolean) 
          : [];
          
        window.generatedRosterData[loc][slot] = assignedIDs.join(", ");
      });
    });

    // Validate and autocorrect the roster
    const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
    const maxIterations = 20;
    let iteration = 0;
    
    // Initial validation
    let { issues, conflicts } = this.validateRoster(window.generatedRosterData, gapThreshold);
    
    // Auto-correction iterations
    while (issues.length > 0 && iteration < maxIterations) {
      if (!this.autoCorrectRoster(window.generatedRosterData, staffList, conflicts)) {
        break; // No more corrections possible
      }
      
      // Re-validate after correction
      const result = this.validateRoster(window.generatedRosterData, gapThreshold);
      issues = result.issues;
      conflicts = result.conflicts;
      
      iteration++;
    }
    
    // If still issues and using 2-hour gap, try with 1-hour gap
    if (issues.length > 0 && gapThreshold > 60) {
      const reducedThreshold = 60;
      iteration = 0;
      
      while (issues.length > 0 && iteration < maxIterations) {
        if (!this.autoCorrectRoster(window.generatedRosterData, staffList, conflicts)) {
          break; // No more corrections possible
        }
        
        // Re-validate with reduced threshold
        const result = this.validateRoster(window.generatedRosterData, reducedThreshold);
        issues = result.issues;
        conflicts = result.conflicts;
        
        iteration++;
      }
      
      // Add remaining issues to shortfalls
      if (issues.length > 0) {
        shortfalls.push(...issues.filter(issue => 
          !issue.includes("violates") || reducedThreshold <= 60 
        ));
      }
    } else if (issues.length > 0) {
      // Add remaining issues to shortfalls
      shortfalls.push(...issues);
    }
    
    // Save the finalized assignments back to the staff rows
    this.saveAssignedToRows(staffList);
    
    // Record the creation time
    const creationTime = new Date();
    
    // Display the roster and notes
    this.displayRoster(window.generatedRosterData, conflicts, creationTime);
    this.displayNotes(shortfalls);
    this.displayBreakList();
    
    // Notify the user
    const healthStatus = shortfalls.length === 0 ? 
      "Optimal roster generated with no issues!" : 
      `Roster generated with ${shortfalls.length} potential issues.`;
      
    this.showSuccess(healthStatus);
    
    return { roster: window.generatedRosterData, shortfalls };
  },

  /**
   * Assign staff to critical locations
   * @param {Object} roster - The roster being built
   * @param {Array} staffList - List of available staff
   * @param {boolean} isWeekend - Whether it's a weekend
   * @param {Array} shortfalls - Array to collect shortfalls
   */
  assignCriticalLocations: function(roster, staffList, isWeekend, shortfalls) {
    for (const loc in CRITICAL_LOCATIONS) {
      // Skip Report Room on weekends
      if (loc === "Report Room" && isWeekend) continue;
      
      for (const slot of CRITICAL_LOCATIONS[loc]) {
        // Initialize slot if needed
        if (!roster[loc][slot]) roster[loc][slot] = "";
        
        // Skip locations that don't apply
        if (!this.locationApplies(loc, slot, isWeekend)) continue;
        
        // Find suitable staff
        let chosen = this.findAvailableStaff(staffList, slot, loc);
        
        if (chosen) {
          // Add to roster
          roster[loc][slot] += roster[loc][slot] ? `, ${chosen.staffID}` : chosen.staffID;
          
          // Record assignment
          chosen.assigned.push({ slot, location: loc });
        } else {
          // Try emergency assignment if no suitable staff found
          chosen = this.findEmergencyStaff(staffList, slot);
          
          if (chosen) {
            // Add emergency staff to roster
            roster[loc][slot] += roster[loc][slot] ? `, ${chosen.staffID}` : chosen.staffID;
            
            // Record assignment
            chosen.assigned.push({ slot, location: loc });
            
            // Note the emergency assignment
            shortfalls.push(`Emergency assignment: ${chosen.staffID} to ${loc} at ${slot}`);
          } else {
            // Critical shortfall - no staff available
            shortfalls.push(`CRITICAL: Could not fill mandatory ${loc} at ${slot}`);
          }
        }
      }
    }
    
    // Check for empty locations
    for (const loc in roster) {
      let allEmpty = true;
      
      for (const slot in roster[loc]) {
        if (roster[loc][slot] && roster[loc][slot].trim() !== "") {
          allEmpty = false;
          break;
        }
      }
      
      if (allEmpty) {
        shortfalls.push(`CRITICAL: ${loc} has zero assignments.`);
      }
    }
  },

  /**
   * Check for critical shortfalls in the roster
   * @param {Object} roster - The roster being built
   * @param {boolean} isWeekend - Whether it's a weekend
   * @param {Array} shortfalls - Array to collect shortfalls
   */
  checkCriticalShortfalls: function(roster, isWeekend, shortfalls) {
    // Check Vertical Patrol critical times
    const vpTimes = ["20:30", "23:00", "01:30", "06:00"];
    for (let vpTime of vpTimes) {
      if (!roster["Vertical Patrol"][vpTime] || roster["Vertical Patrol"][vpTime].length === 0) {
        shortfalls.push(`Missing required Vertical Patrol at ${vpTime}`);
      }
    }
    
    // Check Report Room critical times (weekdays only)
    if (!isWeekend) {
      const reportTimes = ["20:00", "21:00"];
      for (let rpTime of reportTimes) {
        if (!roster["Report Room"][rpTime] || roster["Report Room"][rpTime].length === 0) {
          shortfalls.push(`Missing required Report Room at ${rpTime}`);
        }
      }
    }
    
    // Check Tango Papa at 07:30
    if (!roster["Tango Papa"]["07:30"] || roster["Tango Papa"]["07:30"].length === 0) {
      shortfalls.push(`Missing required Tango Papa at 07:30`);
    }
    
    // Check for Pass Counter staffing (should have 2 staff at all times)
    for (const slot of ROSTER_TIMES) {
      if (slot === "07:30") continue; // Skip 07:30 for Pass Counter
      
      if (!roster["Pass Counter"][slot] || roster["Pass Counter"][slot].split(",").filter(Boolean).length < 2) {
        const count = roster["Pass Counter"][slot] 
          ? roster["Pass Counter"][slot].split(",").filter(Boolean).length 
          : 0;
          
        shortfalls.push(`CRITICAL SHORTFALL: Pass Counter at ${slot} has only ${count}/2 staff`);
      }
    }
    
    // Check for HHMD staffing (should have at least 1 at all times)
    for (const slot of ROSTER_TIMES) {
      if (!roster["HHMD"][slot] || roster["HHMD"][slot].length === 0) {
        shortfalls.push(`CRITICAL SHORTFALL: HHMD at ${slot} has no staff assigned`);
      }
    }
  },

  /**
   * Find an emergency staff member for a slot
   * @param {Array} staffList - List of available staff
   * @param {string} slot - Time slot
   * @returns {Object|null} - Staff object or null if none found
   */
  findEmergencyStaff: function(staffList, slot) {
    for (let st of staffList) {
      if (
        st.attendance === "Yes" && 
        !this.isOnBreak(st, slot) && 
        !this.isDoubleBooked(st, slot)
      ) {
        return st;
      }
    }
    return null;
  },

  /**
   * Find an available staff member for a location and slot
   * @param {Array} staffList - List of available staff
   * @param {string} slot - Time slot
   * @param {string} loc - Location
   * @returns {Object|null} - Staff object or null if none found
   */
  findAvailableStaff: function(staffList, slot, loc) {
    // Sort staff by assignments (prefer staff with fewer assignments)
    const sortedStaff = [...staffList].sort((a, b) => 
      (a.assigned?.length || 0) - (b.assigned?.length || 0)
    );
    
    for (let st of sortedStaff) {
      if (
        st.attendance === "Yes" && 
        !this.isOnBreak(st, slot) &&
        !this.isDoubleBooked(st, slot) &&
        !(loc === "HHMD" && st.hhmdEligible !== "Yes")
      ) {
        return st;
      }
    }
    return null;
  },

  /**
   * Check if staff is on break during a slot
   * @param {Object} st - Staff object
   * @param {string} slot - Time slot
   * @returns {boolean} - Whether the staff is on break
   */
  isOnBreak: function(st, slot) {
    if (!st.breakTime || !st.breakTime.includes("-")) {
      console.log(`No break time or invalid format for ${st.staffID}: ${st.breakTime}`);
      return false;
    }
    
    if (!st.breakTime.match(/^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/)) {
      console.warn(`Invalid break time format for staff ${st.staffID}: ${st.breakTime}`);
      return false;
    }
    
    const [bStart, bEnd] = st.breakTime.split("-");
    
    if (!bStart || !bEnd) {
      console.log(`Invalid break time parts for ${st.staffID}: ${bStart}-${bEnd}`);
      return false;
    }
    
    const slotTime = this.timeToMinutes(slot);
    const breakStart = this.timeToMinutes(bStart);
    const breakEnd = this.timeToMinutes(bEnd);
    
    // Handle cases where break crosses midnight
    if (breakStart <= breakEnd) {
      return (slotTime >= breakStart && slotTime <= breakEnd);
    } else {
      return (slotTime >= breakStart || slotTime <= breakEnd);
    }
  },

  /**
   * Check if staff is already assigned during a slot
   * @param {Object} st - Staff object
   * @param {string} slot - Time slot
   * @returns {boolean} - Whether the staff is already assigned
   */
  isDoubleBooked: function(st, slot) {
    return st.assigned && st.assigned.some(a => a.slot === slot);
  },

  /**
   * Check if adding a staff to a slot would cause a conflict
   * @param {Object} roster - The roster being built
   * @param {Object} staff - Staff object
   * @param {string} slot - Time slot
   * @param {string} loc - Location
   * @returns {boolean} - Whether adding would cause a conflict
   */
  wouldCauseConflict: function(roster, staff, slot, loc) {
    // Check for basic conflicts
    if (this.isOnBreak(staff, slot) || this.isDoubleBooked(staff, slot)) {
      return true;
    }
    
    // Check for gap policy violations
    const potentialAssignments = [...staff.assigned, { slot, location: loc }];
    
    // Sort by time
    potentialAssignments.sort((a, b) => ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot));
    
    // Get gap threshold in minutes
    const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
    
    // Check for violations
    for (let i = 0; i < potentialAssignments.length - 1; i++) {
      const currSlot = potentialAssignments[i].slot;
      const nextSlot = potentialAssignments[i + 1].slot;
      const currLoc = potentialAssignments[i].location;
      const nextLoc = potentialAssignments[i + 1].location;
      
      // Only check gap if same location (we care about gaps at same location)
      if (currLoc === nextLoc) {
        const currTime = this.timeToMinutes(currSlot);
        const nextTime = this.timeToMinutes(nextSlot);
        
        // Check if gap is less than threshold
        if (nextTime - currTime < gapThreshold && nextTime - currTime > 0) {
          return true;
        }
      }
    }
    
    return false;
  },

  /**
   * Auto-correct issues in a roster
   * @param {Object} roster - The roster to correct
   * @param {Array} staffList - List of available staff
   * @param {Object} conflicts - Conflict information
   * @returns {boolean} - Whether any corrections were made
   */
  autoCorrectRoster: function(roster, staffList, conflicts) {
    let correctionsMade = false;
    
    for (let loc in conflicts) {
      for (let slot in conflicts[loc]) {
        let staffObj = conflicts[loc][slot];
        
        for (let staffID in staffObj) {
          // Find the staff in the list
          let staff = staffList.find(s => s.staffID === staffID);
          
          if (staff) {
            // Remove from current assignment
            this.removeAssignment(roster, staff, slot, loc);
            
            // Clean up the roster entry
            let currentAssignments = roster[loc][slot].split(",").map(s => s.trim()).filter(Boolean);
            let uniqueAssignments = [...new Set(currentAssignments)];
            roster[loc][slot] = uniqueAssignments.join(", ");
            
            // Only try to find replacement for non-07:30 slots (except Tango Papa)
            if (slot !== "07:30" || loc === "Tango Papa") {
              // Find a replacement staff
              let newStaff = this.findEmergencyStaff(
                staffList.filter(s => s.staffID !== staffID), 
                slot
              );
              
              // Add replacement if found and wouldn't cause new conflicts
              if (newStaff && 
                  !this.wouldCauseConflict(roster, newStaff, slot, loc) && 
                  !this.isOnBreak(newStaff, slot)) {
                  
                roster[loc][slot] = roster[loc][slot] 
                  ? `${roster[loc][slot]}, ${newStaff.staffID}` 
                  : newStaff.staffID;
                  
                newStaff.assigned.push({ slot, location: loc });
                correctionsMade = true;
              } else {
                correctionsMade = true; // Removal counts as correction
              }
            } else {
              correctionsMade = true; // Removal for 07:30 non-Tango Papa
            }
          }
        }
      }
    }
    
    return correctionsMade;
  },

  /**
   * Remove a staff assignment from the roster
   * @param {Object} roster - The roster to modify
   * @param {Object} staff - Staff object
   * @param {string} slot - Time slot
   * @param {string} loc - Location
   */
  removeAssignment: function(roster, staff, slot, loc) {
    // Remove from staff's assigned list
    staff.assigned = staff.assigned.filter(a => !(a.slot === slot && a.location === loc));
    
    // Remove from roster
    if (roster[loc] && roster[loc][slot]) {
      let ids = roster[loc][slot].split(",").map(s => s.trim()).filter(Boolean);
      ids = ids.filter(id => id !== staff.staffID);
      roster[loc][slot] = ids.join(", ");
    }
  },

  /**
   * Validate a roster to find issues
   * @param {Object} roster - The roster to validate
   * @param {number} gapThreshold - Gap threshold in minutes
   * @returns {Object} - Object with issues and conflicts
   */
  validateRoster: function(roster, gapThreshold = 120) {
    const staffAssignments = {};
    const issues = [];
    const conflicts = {};
    const staffList = this.getCurrentStaffList();

    // Helper function to add a conflict
    function addConflict(loc, slot, staffID, conflictType) {
      if (!conflicts[loc]) conflicts[loc] = {};
      if (!conflicts[loc][slot]) conflicts[loc][slot] = {};
      if (!conflicts[loc][slot][staffID]) conflicts[loc][slot][staffID] = [];
      conflicts[loc][slot][staffID].push(conflictType);
    }

    // Check each location and slot
    for (const loc in roster) {
      for (const slot in roster[loc]) {
        const staffListStr = roster[loc][slot];
        if (!staffListStr) continue;

        // Check for 07:30 assignments outside of Tango Papa
        if (slot === "07:30" && loc !== "Tango Papa") {
          const staffIDs = staffListStr.split(",").map(s => s.trim()).filter(Boolean);
          staffIDs.forEach(staffID => {
            issues.push(`Staff ${staffID} assigned at ${loc} for 07:30, which is reserved for Tango Papa only`);
            addConflict(loc, slot, staffID, "invalid0730");
          });
          continue;
        }

        // Check for duplicate staff in the same slot/location
        const staffIDs = staffListStr.split(",").map(s => s.trim()).filter(Boolean);
        const uniqueStaffIDs = new Set(staffIDs);
        
        if (uniqueStaffIDs.size < staffIDs.length) {
          const duplicates = staffIDs.filter((id, index) => staffIDs.indexOf(id) !== index);
          duplicates.forEach(id => {
            issues.push(`Staff ${id} listed multiple times at ${loc} for ${slot}`);
            addConflict(loc, slot, id, "duplicateAssignment");
          });
        }
        
        // Check for break conflicts and double bookings
        for (const staffID of staffIDs) {
          const staff = staffList.find(s => s.staffID === staffID);
          
          // Check if assigned during break
          if (staff && this.isOnBreak(staff, slot)) {
            issues.push(`Staff ${staffID} assigned at ${loc} during break at ${slot}`);
            addConflict(loc, slot, staffID, "breakViolation");
          }
          
          // Initialize assignments array for this staff if not exist
          if (!staffAssignments[staffID]) staffAssignments[staffID] = [];
          
          // Check for double booking
          const existing = staffAssignments[staffID].find(a => a.slot === slot);
          if (existing) {
            issues.push(`Staff ${staffID} double-booked at ${slot}: ${existing.location} and ${loc}`);
            addConflict(loc, slot, staffID, "doubleBooked");
            addConflict(existing.location, slot, staffID, "doubleBooked");
          }
          
          // Record this assignment
          staffAssignments[staffID].push({ slot, location: loc });
        }
      }
    }

    // Check for gap policy violations
    for (const staffID in staffAssignments) {
      // Sort assignments by time
      const assignments = staffAssignments[staffID].sort((a, b) => 
        ROSTER_TIMES.indexOf(a.slot) - ROSTER_TIMES.indexOf(b.slot)
      );
      
      // Check for consecutive slot assignments at same location
      for (let i = 0; i < assignments.length - 1; i++) {
        const curr = assignments[i];
        const next = assignments[i + 1];
        
        // Check for consecutive slots at same location
        if (curr.location === next.location && 
            Math.abs(ROSTER_TIMES.indexOf(curr.slot) - ROSTER_TIMES.indexOf(next.slot)) === 1) {
          
          issues.push(`Staff ${staffID} has consecutive assignments at ${curr.location}: ${curr.slot} and ${next.slot}`);
          addConflict(curr.location, curr.slot, staffID, "consecutive");
          addConflict(next.location, next.slot, staffID, "consecutive");
        }
        
        // Check for gap policy violations at same location
        if (curr.location === next.location) {
          const currTime = this.timeToMinutes(curr.slot);
          const nextTime = this.timeToMinutes(next.slot);
          
          if (nextTime - currTime < gapThreshold && nextTime - currTime > 0) {
            issues.push(`Staff ${staffID} violates ${gapThreshold/60}-hour gap at ${curr.location}: ${curr.slot} and ${next.slot}`);
            addConflict(curr.location, curr.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
            addConflict(next.location, next.slot, staffID, gapThreshold === 120 ? "twoHourGap" : "oneHourGap");
          }
        }
      }
    }
    
    return { issues, conflicts };
  },

  /**
   * Save assigned data back to the table rows
   * @param {Array} staffList - List of staff objects
   */
  saveAssignedToRows: function(staffList) {
    const rows = document.getElementById("staffTable").querySelector("tbody").rows;
    
    for (let i = 0; i < rows.length; i++) {
      const staffID = rows[i].cells[0].querySelector("input").value.trim();
      const staff = staffList.find(s => s.staffID === staffID);
      
      if (staff) {
        rows[i].dataset.assigned = JSON.stringify(staff.assigned);
      }
    }
    
    this.saveStaffList();
  }
});

/**
 * Staff Roster Management System - Display and Export Module
 * Handles displaying, copying, and exporting roster data
 */

// Extend the rosterSystem with display and export functions
Object.assign(rosterSystem, {
  /**
   * Display the roster in the UI
   * @param {Object} roster - The roster data
   * @param {Object} conflicts - Conflict information
   * @param {Date} creationTime - Time the roster was created
   */
  displayRoster: function(roster, conflicts = {}, creationTime) {
    const container = document.getElementById("rosterContainer");
    const rosterDate = document.getElementById("rosterDate").value;
    const dayValue = document.getElementById("rosterDay").value;
    
    // Create header with metadata
    let headerHTML = `
      <div style="text-align:left; margin-bottom:15px; font-size:13px; display: flex; justify-content: space-between; flex-wrap: wrap;">
        <div>
          <strong>Roster Date:</strong> ${rosterDate} (${dayValue})
        </div>
        <div>
          <strong>Generated:</strong> ${creationTime.toLocaleString()}
        </div>
      </div>
    `;
    
    // Create table structure
    let tableHTML = `
      <table id="editableRoster" class="roster-table">
        <thead>
          <tr>
            <th style="min-width:100px;">Location</th>
    `;
    
    // Add time slots to header
    ROSTER_TIMES.forEach(slot => {
      tableHTML += `<th>${slot}</th>`;
    });
    
    tableHTML += `</tr></thead><tbody>`;
    
    // Check if it's a weekend
    const isWeekend = ["Saturday", "Sunday"].includes(dayValue);
    
    // Add rows for each location
    OUTPUT_ORDER.forEach(loc => {
      tableHTML += `<tr data-loc="${loc}"><td><strong>${loc}</strong></td>`;
      
      // Add cells for each time slot
      ROSTER_TIMES.forEach(slot => {
        // Check if this location applies to this slot
        const applies = this.locationApplies(loc, slot, isWeekend);
        let assignedStr = applies ? (roster[loc]?.[slot] || "") : "";
        
        // Get staff IDs from the assignment string
        let staffIDs = assignedStr.split(",").map(s => s.trim()).filter(Boolean);
        
        // Determine cell styling
        let cellClass = "";
        let cellStyle = "";
        
        if (!applies) {
          // Not applicable cell
          cellStyle = "background-color:#f8f8f8; color:#999;";
          cellClass = "non-applicable";
        } else if (conflicts[loc] && conflicts[loc][slot]) {
          // Cell with conflicts
          cellStyle = "background-color:#ffd2d2;";
          cellClass = "conflict";
        } else if (applies && staffIDs.length === 0) {
          // Empty applicable cell (critical)
          cellStyle = "background-color:#ffcccc;";
          cellClass = "empty";
        } else if (CRITICAL_LOCATIONS[loc] && CRITICAL_LOCATIONS[loc].includes(slot)) {
          // Critical location/time
          cellStyle = "background-color:#e2f0ff;";
          cellClass = "critical";
        }
        
        // Create the cell
        tableHTML += `
          <td 
            contenteditable="true" 
            data-slot="${slot}" 
            class="${cellClass}"
            style="min-width:80px; ${cellStyle}"
            title="${applies ? 'Click to edit assignments' : 'Not applicable for this location/time'}"
          >
            ${assignedStr}
          </td>`;
      });
      
      tableHTML += `</tr>`;
    });
    
    tableHTML += `</tbody></table>`;
    
    // Add save button
    let saveButtonHTML = `
      <div style="margin-top:15px; text-align:right;">
        <button class="roster-btn" id="saveEditsBtn">Save Edits</button>
      </div>
    `;
    
    // Update the container
    container.innerHTML = headerHTML + tableHTML + saveButtonHTML;
    
    // Add event listener for save button
    document.getElementById("saveEditsBtn").addEventListener("click", () => this.saveEditedRoster());
    
    // Add event listeners for editable cells
    const editableCells = container.querySelectorAll("td[contenteditable='true']");
    
    editableCells.forEach(cell => {
      // Highlight cells on focus
      cell.addEventListener("focus", function() {
        this.style.boxShadow = "0 0 0 2px rgba(79, 70, 229, 0.4)";
      });
      
      // Remove highlight on blur
      cell.addEventListener("blur", function() {
        this.style.boxShadow = "";
      });
    });
  },

  /**
   * Display roster health notes
   * @param {Array} shortfalls - Array of shortfall messages
   */
  displayNotes: function(shortfalls) {
    const notesContainer = document.getElementById("notesContainer");
    
    if (!shortfalls.length) {
      // No issues
      notesContainer.innerHTML = `
        <div class="status-message success">
          <span class="status-indicator status-success"></span>
          Roster Health: All clear. No issues detected.
        </div>
      `;
    } else {
      // Count types of issues
      const criticalCount = shortfalls.filter(note => note.toUpperCase().includes("CRITICAL")).length;
      const warningCount = shortfalls.length - criticalCount;
      
      // Create status message
      let statusClass = criticalCount > 0 ? "danger" : (warningCount > 0 ? "warning" : "success");
      let statusHtml = `
        <div class="status-message ${statusClass}">
          <span class="status-indicator status-${statusClass}"></span>
          Roster Health: ${criticalCount} critical issues, ${warningCount} warnings
        </div>
      `;
      
      // Add list of issues if any
      if (shortfalls.length > 0) {
        statusHtml += `<ul class="shortfall-list" style="text-align: left; margin-top: 10px; font-size: 12px;">`;
        
        shortfalls.forEach(note => {
          // Determine if this is a critical issue
          const isCritical = note.toUpperCase().includes("CRITICAL");
          const style = isCritical ? "color: #EF4444; font-weight: bold;" : "color: #F59E0B;";
          
          statusHtml += `<li style="${style}">${note}</li>`;
        });
        
        statusHtml += `</ul>`;
      }
      
      notesContainer.innerHTML = statusHtml;
    }
  },

  /**
   * Save edits made to the roster
   */
  saveEditedRoster: function() {
    try {
      // Get the table
      const rosterTable = document.getElementById("editableRoster");
      
      if (!rosterTable) {
        this.showError("No roster table found to save edits from.");
        return;
      }
      
      // Get current staff list
      const staffList = this.getCurrentStaffList();
      
      // Reset all assignments
      staffList.forEach(staff => {
        if (!staff.locked) {
          staff.assigned = [];
        }
      });
      
      // Process each row (location)
      const rows = rosterTable.querySelectorAll("tbody tr");
      
      rows.forEach(row => {
        const location = row.getAttribute("data-loc");
        
        // Process each cell (time slot)
        const cells = row.querySelectorAll("td[data-slot]");
        
        cells.forEach(cell => {
          const slot = cell.getAttribute("data-slot");
          const staffIDs = cell.textContent.split(",").map(id => id.trim()).filter(Boolean);
          
          // Assign each staff to this location/slot
          staffIDs.forEach(staffID => {
            const staff = staffList.find(s => s.staffID === staffID);
            
            if (staff && staff.attendance === "Yes") {
              if (!staff.locked) {
                // Add this assignment
                staff.assigned.push({ slot, location });
              }
            }
          });
        });
      });
      
      // Save updated assignments back to table rows
      this.saveAssignedToRows(staffList);
      
      // Update the roster display with validation
      const gapThreshold = parseInt(document.getElementById("gapThreshold").value, 10) || 120;
      const { issues, conflicts } = this.validateRoster(this.getEditableRosterData(), gapThreshold);
      
      // Update the display with new validation
      this.displayNotes(issues);
      
      // Success message
      this.showSuccess("Roster edits saved successfully!");
    } catch (error) {
      console.error("Error saving roster edits:", error);
      this.showError("Failed to save roster edits: " + error.message);
    }
  },

  /**
   * Get data from the editable roster table
   * @returns {Object} - Roster data object
   */
  getEditableRosterData: function() {
    const rosterTable = document.getElementById("editableRoster");
    
    if (!rosterTable) {
      return {};
    }
    
    // Initialize roster object
    const roster = {};
    
    // Process each row (location)
    const rows = rosterTable.querySelectorAll("tbody tr");
    
    rows.forEach(row => {
      const location = row.getAttribute("data-loc");
      roster[location] = {};
      
      // Process each cell (time slot)
      const cells = row.querySelectorAll("td[data-slot]");
      
      cells.forEach(cell => {
        const slot = cell.getAttribute("data-slot");
        roster[location][slot] = cell.textContent.trim();
      });
    });
    
    return roster;
  },

  /**
   * Get table data in a 2D array format
   * @returns {Array} - 2D array of table data
   */
  getTableData: function() {
    const rosterTable = document.getElementById("editableRoster");
    
    if (!rosterTable) {
      return [];
    }
    
    const data = [];
    const rows = rosterTable.querySelectorAll("tr");
    
    // Process each row
    rows.forEach(row => {
      const rowData = [];
      
      // Process each cell
      row.querySelectorAll("th, td").forEach(cell => {
        rowData.push(cell.textContent.trim());
      });
      
      data.push(rowData);
    });
    
    return data;
  },

  /**
   * Get staff break data in a 2D array format
   * @returns {Array} - 2D array of staff break data
   */
  getStaffBreakData: function() {
    const staffList = this.getCurrentStaffList().filter(st => st.attendance === "Yes");
    let data = [["Staff ID", "Name", "Break Time"]];
    
    // Sort staff by ID
    staffList.sort((a, b) => a.staffID.localeCompare(b.staffID));
    
    // Add each staff member's break time
    staffList.forEach(st => {
      data.push([st.staffID, st.name, st.breakTime]);
    });
    
    return data;
  },

  /**
   * Download the roster in the specified format
   * @param {string} format - 'csv' or 'pdf'
   */
  downloadRoster: function(format) {
    const rosterData = this.getTableData();
    
    if (!rosterData.length) {
      this.showError("No roster data found. Please generate the roster first.");
      return;
    }
    
    const breakData = this.getStaffBreakData();
    const rosterDate = document.getElementById('rosterDate').value;
    const dayValue = document.getElementById('rosterDay').value;
    const fileName = `Roster_${rosterDate}_${dayValue}`;
    
    if (format === "csv") {
      this.downloadAsCSV(rosterData, breakData, fileName);
    } else if (format === "pdf") {
      this.downloadAsPDF(rosterData, breakData, fileName);
    }
  },

  /**
   * Download data as a CSV file
   * @param {Array} rosterData - Roster table data
   * @param {Array} breakData - Staff break data
   * @param {string} baseFileName - Base file name
   */
  downloadAsCSV: function(rosterData, breakData, baseFileName) {
    try {
      // Convert arrays to CSV strings
      const convertToCSV = (arr) => {
        return arr.map(row => 
          row.map(cell => 
            // Quote cells and escape double quotes
            `"${String(cell).replace(/"/g, '""')}"`
          ).join(",")
        ).join("\n");
      };
      
      const rosterCSV = convertToCSV(rosterData);
      const breakCSV = convertToCSV(breakData);
      
      // Combine into final CSV with a separator
      const finalCSV = rosterCSV + "\n\nStaff Break Times:\n" + breakCSV;
      
      // Create a blob and download
      const blob = new Blob([finalCSV], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      
      link.href = url;
      link.setAttribute("download", `${baseFileName}.csv`);
      document.body.appendChild(link);
      link.click();
      
      // Clean up
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      this.showSuccess("CSV downloaded successfully.");
    } catch (error) {
      console.error("Error creating CSV:", error);
      this.showError("Failed to create CSV: " + error.message);
    }
  },

  /**
   * Download data as a PDF file
   * @param {Array} rosterData - Roster table data
   * @param {Array} breakData - Staff break data
   * @param {string} baseFileName - Base file name
   */
  downloadAsPDF: function(rosterData, breakData, baseFileName) {
    try {
      // Check if jsPDF is available
      if (typeof jsPDF === "undefined" || !window.jspdf) {
        this.showError("jsPDF library not found. PDF export not available.");
        return;
      }
      
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('landscape', 'pt', 'a4');
      
      // Add metadata
      const rosterDate = document.getElementById("rosterDate").value;
      const dayValue = document.getElementById("rosterDay").value;
      const creationTime = new Date().toLocaleString();
      
      // Add title and metadata
      doc.setFontSize(16);
      doc.text("Staff Roster", 40, 30);
      
      doc.setFontSize(10);
      doc.text(`Roster Date: ${rosterDate} (${dayValue}) | Generated on: ${creationTime}`, 40, 50);
      
      // Add roster table
      doc.setFontSize(12);
      doc.text("Roster", 40, 80);
      
      doc.autoTable({
        startY: 90,
        head: [rosterData[0]],
        body: rosterData.slice(1),
        margin: { left: 40 },
        theme: 'grid',
        styles: { fontSize: 8, cellPadding: 3 },
        headStyles: { fillColor: [79, 70, 229], textColor: [255, 255, 255] }
      });
      
      // Add staff break table
      let finalY = doc.lastAutoTable.finalY + 30;
      
      doc.text("Staff Break Times", 40, finalY);
      
      doc.autoTable({
        startY: finalY + 10,
        head: [breakData[0]],
        body: breakData.slice(1),
        margin: { left: 40 },
        theme: 'striped',
        styles: { fontSize: 8, cellPadding: 4 },
        columnStyles: {
          0: { cellWidth: 80 },
          1: { cellWidth: 120 },
          2: { cellWidth: 80 }
        },
        headStyles: { fillColor: [79, 70, 229], textColor: [255, 255, 255] }
      });
      
      // Save the PDF
      doc.save(`${baseFileName}.pdf`);
      
      this.showSuccess("PDF downloaded successfully.");
    } catch (error) {
      console.error("Error creating PDF:", error);
      this.showError("Failed to create PDF: " + error.message);
    }
  },

  /**
   * Copy roster as TSV (tab-separated values) to clipboard
   */
  copyTSV: function() {
    try {
      const rosterTable = document.getElementById("editableRoster");
      
      if (!rosterTable) {
        this.showError("No generated roster table found to copy.");
        return;
      }
      
      let tsv = "";
      const rows = rosterTable.querySelectorAll("tr");
      
      // Process each row
      rows.forEach(row => {
        const cells = row.querySelectorAll("th, td");
        let rowData = [];
        
        // Process each cell
        cells.forEach(cell => {
          rowData.push(cell.textContent.trim());
        });
        
        // Add row to TSV
        tsv += rowData.join("\t") + "\n";
      });
      
      // Copy to clipboard
      navigator.clipboard.writeText(tsv).then(() => {
        this.showSuccess("Roster copied as TSV to clipboard!");
      }).catch(err => {
        console.error("Clipboard error:", err);
        this.showError("Unable to copy to clipboard: " + err.message);
      });
    } catch (error) {
      console.error("Error creating TSV:", error);
      this.showError("Failed to create TSV: " + error.message);
    }
  }
});

// Initialize the system when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', function() {
  // Start the roster system
  rosterSystem.init();
  
  console.log("Roster Management System v2.0 loaded successfully!");
});