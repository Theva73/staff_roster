// Time slot constants
const HALF_HOURS = [
    "20:00","20:30","21:00","21:30","22:00","22:30","23:00","23:30",
    "00:00","00:30","01:00","01:30","02:00","02:30","03:00","03:30",
    "04:00","04:30","05:00","05:30","06:00","06:30","07:00","07:30"
];

// Location priority and staffing needs
const PRIORITY = [
    { location: "Pass Counter", needed: 2 },
    { location: "HHMD", needed: 1 },
    { location: "Lobby", needed: 2 },
    { location: "Guard House", needed: 1 },
    { location: "Vertical Patrol", needed: 1 },
    { location: "Report Room", needed: 1 },
    { location: "Tango Papa", needed: 1 }
];

// Break time check
function staffAvailableHalfHour(st, slot) {
    const [bStart, bEnd] = st.breakTime.split("-");
    if (!bStart || !bEnd) return true;
    
    // Direct comparison for break period
    if (slot >= bStart && slot <= bEnd) {
        return false; // Staff is on break
    }
    return true;
}

// Eligibility check with all constraints
function isStaffEligible(st, slot, loc) {
    // Basic checks
    if (st.attendance !== "Yes") return false;
    if (st.locked && !alreadyAssignedSlot(st, slot)) return false;
    
    // Break time check
    if (!staffAvailableHalfHour(st, slot)) return false;
    
    // Assignment checks
    if (st.assigned.some(a => a.slot === slot)) return false;
    
    // Special location requirements
    if (loc === "HHMD" && st.hhmdEligible !== "Yes") return false;
    
    // Back-to-back prevention
    if (loc !== "Lobby" && isBackToBack(st, slot, loc)) return false;
    
    // 2-hour gap rule
    if (violates2HourGap(st, slot, loc)) return false;
    
    return true;
}

// Back-to-back prevention
function isBackToBack(st, slot, loc) {
    const idx = HALF_HOURS.indexOf(slot);
    if (idx <= 0) return false;
    
    const prevSlot = HALF_HOURS[idx-1];
    const nextSlot = HALF_HOURS[idx+1];
    
    // Check both previous and next slots
    return st.assigned.some(a => 
        (a.slot === prevSlot || a.slot === nextSlot) && 
        a.location === loc
    );
}

// Check for existing assignment
function alreadyAssignedSlot(st, slot) {
    return st.assigned.some(a => a.slot === slot);
}

// 2-hour gap rule check
function violates2HourGap(st, slot, loc) {
    const idx = HALF_HOURS.indexOf(slot);
    for (let i = 1; i <= 4; i++) {
        if (idx - i < 0) break;
        const checkSlot = HALF_HOURS[idx - i];
        if (st.assigned.some(a => a.slot === checkSlot && a.location === loc)) {
            return true;
        }
    }
    return false;
}

// Location availability check
function locationApplies(loc, slot, isWeekend) {
    if (loc === "Vertical Patrol") {
        return ["20:00","23:00","01:00","06:00"].includes(slot);
    }
    if (loc === "Report Room") {
        if (isWeekend) return false;
        return ["20:00","21:00"].includes(slot);
    }
    if (loc === "Tango Papa") {
        return slot === "07:30";
    }
    return true;
}

// Staff selection with conflict prevention
function pickStaffForSlot(staffList, slot, loc) {
    // First pass: normal selection with all constraints
    for (let st of staffList) {
        if (!isStaffEligible(st, slot, loc)) continue;
        if (loc === "Lobby" && isLobbyRepeat(st, slot)) continue;
        return st;
    }
    
    // Second pass: relaxed constraints for Lobby only
    if (loc === "Lobby") {
        for (let st of staffList) {
            if (!isStaffEligible(st, slot, loc)) continue;
            return st;
        }
    }
    return null;
}

// Special Lobby repeat prevention
function isLobbyRepeat(st, slot) {
    const idx = HALF_HOURS.indexOf(slot);
    if (idx <= 0) return false;
    const prevSlot = HALF_HOURS[idx-1];
    return st.assigned.some(a => a.slot === prevSlot && a.location === "Lobby");
}

// Main roster generation function
function generateRoster() {
    const dayValue = document.getElementById("rosterDay").value;
    const isWeekend = (dayValue === "Saturday" || dayValue === "Sunday");
    
    let staffList = getCurrentStaffList();
    // Clear previous assignments for unlocked staff
    staffList.forEach(st => {
        if (!st.locked) st.assigned = [];
    });
    
    let roster = {};
    OUTPUT_ORDER.forEach(loc => { roster[loc] = {}; });
    let shortfalls = [];
    
    // Generate assignments
    for (let slot of HALF_HOURS) {
        for (let p of PRIORITY) {
            let loc = p.location;
            if (!locationApplies(loc, slot, isWeekend)) continue;
            
            let needed = p.needed;
            if (!roster[loc][slot]) roster[loc][slot] = [];
            let assignedCount = roster[loc][slot].length;
            
            while (assignedCount < needed) {
                let chosen = pickStaffForSlot(staffList, slot, loc);
                if (!chosen) break;
                
                roster[loc][slot].push(chosen.staffID);
                chosen.assigned.push({ slot, location: loc });
                assignedCount++;
            }
            
            // Track shortfalls for critical positions
            if ((loc === "Pass Counter" || loc === "Lobby") && assignedCount < needed) {
                shortfalls.push(`Shortfall at ${loc} for ${slot}. Needed ${needed}, got ${assignedCount}.`);
            }
        }
    }
    
    // Save and display results
    saveAssignedToRows(staffList);
    displayRoster(roster);
    displayNotes(shortfalls);
}